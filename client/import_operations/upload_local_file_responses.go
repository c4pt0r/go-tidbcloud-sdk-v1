// Code generated by go-swagger; DO NOT EDIT.

package import_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UploadLocalFileReader is a Reader for the UploadLocalFile structure.
type UploadLocalFileReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *UploadLocalFileReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewUploadLocalFileOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewUploadLocalFileBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewUploadLocalFileUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewUploadLocalFileForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewUploadLocalFileNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewUploadLocalFileTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewUploadLocalFileInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewUploadLocalFileDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewUploadLocalFileOK creates a UploadLocalFileOK with default headers values
func NewUploadLocalFileOK() *UploadLocalFileOK {
	return &UploadLocalFileOK{}
}

/*
UploadLocalFileOK describes a response with status code 200, with default header values.

A successful response.
*/
type UploadLocalFileOK struct {
	Payload *UploadLocalFileOKBody
}

// IsSuccess returns true when this upload local file o k response has a 2xx status code
func (o *UploadLocalFileOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this upload local file o k response has a 3xx status code
func (o *UploadLocalFileOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this upload local file o k response has a 4xx status code
func (o *UploadLocalFileOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this upload local file o k response has a 5xx status code
func (o *UploadLocalFileOK) IsServerError() bool {
	return false
}

// IsCode returns true when this upload local file o k response a status code equal to that given
func (o *UploadLocalFileOK) IsCode(code int) bool {
	return code == 200
}

func (o *UploadLocalFileOK) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileOK  %+v", 200, o.Payload)
}

func (o *UploadLocalFileOK) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileOK  %+v", 200, o.Payload)
}

func (o *UploadLocalFileOK) GetPayload() *UploadLocalFileOKBody {
	return o.Payload
}

func (o *UploadLocalFileOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UploadLocalFileOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUploadLocalFileBadRequest creates a UploadLocalFileBadRequest with default headers values
func NewUploadLocalFileBadRequest() *UploadLocalFileBadRequest {
	return &UploadLocalFileBadRequest{}
}

/*
UploadLocalFileBadRequest describes a response with status code 400, with default header values.

A request field is invalid.
*/
type UploadLocalFileBadRequest struct {
	Payload *UploadLocalFileBadRequestBody
}

// IsSuccess returns true when this upload local file bad request response has a 2xx status code
func (o *UploadLocalFileBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this upload local file bad request response has a 3xx status code
func (o *UploadLocalFileBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this upload local file bad request response has a 4xx status code
func (o *UploadLocalFileBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this upload local file bad request response has a 5xx status code
func (o *UploadLocalFileBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this upload local file bad request response a status code equal to that given
func (o *UploadLocalFileBadRequest) IsCode(code int) bool {
	return code == 400
}

func (o *UploadLocalFileBadRequest) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileBadRequest  %+v", 400, o.Payload)
}

func (o *UploadLocalFileBadRequest) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileBadRequest  %+v", 400, o.Payload)
}

func (o *UploadLocalFileBadRequest) GetPayload() *UploadLocalFileBadRequestBody {
	return o.Payload
}

func (o *UploadLocalFileBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UploadLocalFileBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUploadLocalFileUnauthorized creates a UploadLocalFileUnauthorized with default headers values
func NewUploadLocalFileUnauthorized() *UploadLocalFileUnauthorized {
	return &UploadLocalFileUnauthorized{}
}

/*
UploadLocalFileUnauthorized describes a response with status code 401, with default header values.

The API key cannot be authenticated.
*/
type UploadLocalFileUnauthorized struct {
	Payload interface{}
}

// IsSuccess returns true when this upload local file unauthorized response has a 2xx status code
func (o *UploadLocalFileUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this upload local file unauthorized response has a 3xx status code
func (o *UploadLocalFileUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this upload local file unauthorized response has a 4xx status code
func (o *UploadLocalFileUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this upload local file unauthorized response has a 5xx status code
func (o *UploadLocalFileUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this upload local file unauthorized response a status code equal to that given
func (o *UploadLocalFileUnauthorized) IsCode(code int) bool {
	return code == 401
}

func (o *UploadLocalFileUnauthorized) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileUnauthorized  %+v", 401, o.Payload)
}

func (o *UploadLocalFileUnauthorized) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileUnauthorized  %+v", 401, o.Payload)
}

func (o *UploadLocalFileUnauthorized) GetPayload() interface{} {
	return o.Payload
}

func (o *UploadLocalFileUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUploadLocalFileForbidden creates a UploadLocalFileForbidden with default headers values
func NewUploadLocalFileForbidden() *UploadLocalFileForbidden {
	return &UploadLocalFileForbidden{}
}

/*
UploadLocalFileForbidden describes a response with status code 403, with default header values.

The API key does not have permission to access the resource.
*/
type UploadLocalFileForbidden struct {
	Payload *UploadLocalFileForbiddenBody
}

// IsSuccess returns true when this upload local file forbidden response has a 2xx status code
func (o *UploadLocalFileForbidden) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this upload local file forbidden response has a 3xx status code
func (o *UploadLocalFileForbidden) IsRedirect() bool {
	return false
}

// IsClientError returns true when this upload local file forbidden response has a 4xx status code
func (o *UploadLocalFileForbidden) IsClientError() bool {
	return true
}

// IsServerError returns true when this upload local file forbidden response has a 5xx status code
func (o *UploadLocalFileForbidden) IsServerError() bool {
	return false
}

// IsCode returns true when this upload local file forbidden response a status code equal to that given
func (o *UploadLocalFileForbidden) IsCode(code int) bool {
	return code == 403
}

func (o *UploadLocalFileForbidden) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileForbidden  %+v", 403, o.Payload)
}

func (o *UploadLocalFileForbidden) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileForbidden  %+v", 403, o.Payload)
}

func (o *UploadLocalFileForbidden) GetPayload() *UploadLocalFileForbiddenBody {
	return o.Payload
}

func (o *UploadLocalFileForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UploadLocalFileForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUploadLocalFileNotFound creates a UploadLocalFileNotFound with default headers values
func NewUploadLocalFileNotFound() *UploadLocalFileNotFound {
	return &UploadLocalFileNotFound{}
}

/*
UploadLocalFileNotFound describes a response with status code 404, with default header values.

The requested resource does not exist.
*/
type UploadLocalFileNotFound struct {
	Payload *UploadLocalFileNotFoundBody
}

// IsSuccess returns true when this upload local file not found response has a 2xx status code
func (o *UploadLocalFileNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this upload local file not found response has a 3xx status code
func (o *UploadLocalFileNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this upload local file not found response has a 4xx status code
func (o *UploadLocalFileNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this upload local file not found response has a 5xx status code
func (o *UploadLocalFileNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this upload local file not found response a status code equal to that given
func (o *UploadLocalFileNotFound) IsCode(code int) bool {
	return code == 404
}

func (o *UploadLocalFileNotFound) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileNotFound  %+v", 404, o.Payload)
}

func (o *UploadLocalFileNotFound) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileNotFound  %+v", 404, o.Payload)
}

func (o *UploadLocalFileNotFound) GetPayload() *UploadLocalFileNotFoundBody {
	return o.Payload
}

func (o *UploadLocalFileNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UploadLocalFileNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUploadLocalFileTooManyRequests creates a UploadLocalFileTooManyRequests with default headers values
func NewUploadLocalFileTooManyRequests() *UploadLocalFileTooManyRequests {
	return &UploadLocalFileTooManyRequests{}
}

/*
UploadLocalFileTooManyRequests describes a response with status code 429, with default header values.

You have exceed the rate limit.
*/
type UploadLocalFileTooManyRequests struct {
	Payload *UploadLocalFileTooManyRequestsBody
}

// IsSuccess returns true when this upload local file too many requests response has a 2xx status code
func (o *UploadLocalFileTooManyRequests) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this upload local file too many requests response has a 3xx status code
func (o *UploadLocalFileTooManyRequests) IsRedirect() bool {
	return false
}

// IsClientError returns true when this upload local file too many requests response has a 4xx status code
func (o *UploadLocalFileTooManyRequests) IsClientError() bool {
	return true
}

// IsServerError returns true when this upload local file too many requests response has a 5xx status code
func (o *UploadLocalFileTooManyRequests) IsServerError() bool {
	return false
}

// IsCode returns true when this upload local file too many requests response a status code equal to that given
func (o *UploadLocalFileTooManyRequests) IsCode(code int) bool {
	return code == 429
}

func (o *UploadLocalFileTooManyRequests) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileTooManyRequests  %+v", 429, o.Payload)
}

func (o *UploadLocalFileTooManyRequests) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileTooManyRequests  %+v", 429, o.Payload)
}

func (o *UploadLocalFileTooManyRequests) GetPayload() *UploadLocalFileTooManyRequestsBody {
	return o.Payload
}

func (o *UploadLocalFileTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UploadLocalFileTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUploadLocalFileInternalServerError creates a UploadLocalFileInternalServerError with default headers values
func NewUploadLocalFileInternalServerError() *UploadLocalFileInternalServerError {
	return &UploadLocalFileInternalServerError{}
}

/*
UploadLocalFileInternalServerError describes a response with status code 500, with default header values.

Server error.
*/
type UploadLocalFileInternalServerError struct {
	Payload *UploadLocalFileInternalServerErrorBody
}

// IsSuccess returns true when this upload local file internal server error response has a 2xx status code
func (o *UploadLocalFileInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this upload local file internal server error response has a 3xx status code
func (o *UploadLocalFileInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this upload local file internal server error response has a 4xx status code
func (o *UploadLocalFileInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this upload local file internal server error response has a 5xx status code
func (o *UploadLocalFileInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this upload local file internal server error response a status code equal to that given
func (o *UploadLocalFileInternalServerError) IsCode(code int) bool {
	return code == 500
}

func (o *UploadLocalFileInternalServerError) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileInternalServerError  %+v", 500, o.Payload)
}

func (o *UploadLocalFileInternalServerError) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] uploadLocalFileInternalServerError  %+v", 500, o.Payload)
}

func (o *UploadLocalFileInternalServerError) GetPayload() *UploadLocalFileInternalServerErrorBody {
	return o.Payload
}

func (o *UploadLocalFileInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UploadLocalFileInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUploadLocalFileDefault creates a UploadLocalFileDefault with default headers values
func NewUploadLocalFileDefault(code int) *UploadLocalFileDefault {
	return &UploadLocalFileDefault{
		_statusCode: code,
	}
}

/*
UploadLocalFileDefault describes a response with status code -1, with default header values.

An unexpected error response.
*/
type UploadLocalFileDefault struct {
	_statusCode int

	Payload *UploadLocalFileDefaultBody
}

// Code gets the status code for the upload local file default response
func (o *UploadLocalFileDefault) Code() int {
	return o._statusCode
}

// IsSuccess returns true when this upload local file default response has a 2xx status code
func (o *UploadLocalFileDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this upload local file default response has a 3xx status code
func (o *UploadLocalFileDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this upload local file default response has a 4xx status code
func (o *UploadLocalFileDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this upload local file default response has a 5xx status code
func (o *UploadLocalFileDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this upload local file default response a status code equal to that given
func (o *UploadLocalFileDefault) IsCode(code int) bool {
	return o._statusCode == code
}

func (o *UploadLocalFileDefault) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] UploadLocalFile default  %+v", o._statusCode, o.Payload)
}

func (o *UploadLocalFileDefault) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file][%d] UploadLocalFile default  %+v", o._statusCode, o.Payload)
}

func (o *UploadLocalFileDefault) GetPayload() *UploadLocalFileDefaultBody {
	return o.Payload
}

func (o *UploadLocalFileDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UploadLocalFileDefaultBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
UploadLocalFileBadRequestBody upload local file bad request body
swagger:model UploadLocalFileBadRequestBody
*/
type UploadLocalFileBadRequestBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this upload local file bad request body
func (o *UploadLocalFileBadRequestBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this upload local file bad request body based on context it is used
func (o *UploadLocalFileBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileBadRequestBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileBody UploadLocalFileReq
//
// UploadLocalFileReq is the request to upload an import task.
swagger:model UploadLocalFileBody
*/
type UploadLocalFileBody struct {

	// The local file name to be uploaded. Only CSV files are supported. The maximum length of the file name is 255 characters.
	//
	// **Note:**
	// * Provide only the basename of the file. For example, instead of specifying `/foo/bar/example_file.csv`, specify only `example_file.csv`. If you do specify a full file path, this endpoint will only use the basename as the file name.
	// * The directory name is not supported. For example: `/foobar/` is invalid.
	// Example: test.csv
	// Required: true
	// Max Length: 255
	LocalFileName *string `json:"local_file_name"`

	// payload
	// Required: true
	Payload *UploadLocalFileParamsBodyPayload `json:"payload"`
}

// Validate validates this upload local file body
func (o *UploadLocalFileBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLocalFileName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePayload(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UploadLocalFileBody) validateLocalFileName(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"local_file_name", "body", o.LocalFileName); err != nil {
		return err
	}

	if err := validate.MaxLength("body"+"."+"local_file_name", "body", *o.LocalFileName, 255); err != nil {
		return err
	}

	return nil
}

func (o *UploadLocalFileBody) validatePayload(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"payload", "body", o.Payload); err != nil {
		return err
	}

	if o.Payload != nil {
		if err := o.Payload.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "payload")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "payload")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this upload local file body based on the context it is used
func (o *UploadLocalFileBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePayload(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UploadLocalFileBody) contextValidatePayload(ctx context.Context, formats strfmt.Registry) error {

	if o.Payload != nil {
		if err := o.Payload.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "payload")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "payload")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileDefaultBody upload local file default body
swagger:model UploadLocalFileDefaultBody
*/
type UploadLocalFileDefaultBody struct {

	// code
	Code int32 `json:"code,omitempty"`

	// details
	Details []*UploadLocalFileDefaultBodyDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`
}

// Validate validates this upload local file default body
func (o *UploadLocalFileDefaultBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UploadLocalFileDefaultBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("UploadLocalFile default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("UploadLocalFile default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this upload local file default body based on the context it is used
func (o *UploadLocalFileDefaultBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UploadLocalFileDefaultBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("UploadLocalFile default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("UploadLocalFile default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileDefaultBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileDefaultBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileDefaultBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileDefaultBodyDetailsItems0 upload local file default body details items0
swagger:model UploadLocalFileDefaultBodyDetailsItems0
*/
type UploadLocalFileDefaultBodyDetailsItems0 struct {

	// at type
	AtType string `json:"@type,omitempty"`
}

// Validate validates this upload local file default body details items0
func (o *UploadLocalFileDefaultBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this upload local file default body details items0 based on context it is used
func (o *UploadLocalFileDefaultBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileDefaultBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileDefaultBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileDefaultBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileForbiddenBody upload local file forbidden body
swagger:model UploadLocalFileForbiddenBody
*/
type UploadLocalFileForbiddenBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this upload local file forbidden body
func (o *UploadLocalFileForbiddenBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this upload local file forbidden body based on context it is used
func (o *UploadLocalFileForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileForbiddenBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileInternalServerErrorBody upload local file internal server error body
swagger:model UploadLocalFileInternalServerErrorBody
*/
type UploadLocalFileInternalServerErrorBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this upload local file internal server error body
func (o *UploadLocalFileInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this upload local file internal server error body based on context it is used
func (o *UploadLocalFileInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileNotFoundBody upload local file not found body
swagger:model UploadLocalFileNotFoundBody
*/
type UploadLocalFileNotFoundBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this upload local file not found body
func (o *UploadLocalFileNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this upload local file not found body based on context it is used
func (o *UploadLocalFileNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileNotFoundBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileOKBody UploadLocalFileResp
//
// UploadLocalFileResp is the response to upload an import task.
swagger:model UploadLocalFileOKBody
*/
type UploadLocalFileOKBody struct {

	// The stub ID for the uploaded file. You can use this stub ID to [create an import task](#tag/Import/operation/CreateImportTask).
	// Example: 123
	// Required: true
	UploadStubID *string `json:"upload_stub_id"`
}

// Validate validates this upload local file o k body
func (o *UploadLocalFileOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateUploadStubID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UploadLocalFileOKBody) validateUploadStubID(formats strfmt.Registry) error {

	if err := validate.Required("uploadLocalFileOK"+"."+"upload_stub_id", "body", o.UploadStubID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this upload local file o k body based on context it is used
func (o *UploadLocalFileOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileOKBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileParamsBodyPayload LocalFilePayload
//
// The payload to upload the local file content for an import task.
swagger:model UploadLocalFileParamsBodyPayload
*/
type UploadLocalFileParamsBodyPayload struct {

	// The base64-encoded content of the local file to be imported. The maximum size of the file should be 52428800 (50 MiB).
	//
	// **Note:** Before providing the content, process the file by taking the following steps:
	// 1. Compress the file using the **gzip** algorithm.
	// 2. Encode the compressed data using the **base64** algorithm.
	// Example: H4sIABbP9mMAAyXHOwoAIQwFwN5jvPoh5neggI2w9Z7fSJqBOZt/fvLQIURmLgFlrqE9BbVmPQOt5j0HvRa9AKN2AUwss6dTAAAA
	// Required: true
	// Max Length: 52428800
	// Format: byte
	Content *strfmt.Base64 `json:"content"`

	// The total size of the **ACTUAL** local file contents, not the total size of the `content` field.
	//
	// The unit is byte, and the maximum value is `52428800` (50 MiB). If the given value of `total_size_bytes` exceeds the maximum value, an error will be reported.
	// Example: 83
	// Required: true
	TotalSizeBytes *string `json:"total_size_bytes"`
}

// Validate validates this upload local file params body payload
func (o *UploadLocalFileParamsBodyPayload) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalSizeBytes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UploadLocalFileParamsBodyPayload) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"payload"+"."+"content", "body", o.Content); err != nil {
		return err
	}

	if err := validate.MaxLength("body"+"."+"payload"+"."+"content", "body", o.Content.String(), 52428800); err != nil {
		return err
	}

	return nil
}

func (o *UploadLocalFileParamsBodyPayload) validateTotalSizeBytes(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"payload"+"."+"total_size_bytes", "body", o.TotalSizeBytes); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this upload local file params body payload based on context it is used
func (o *UploadLocalFileParamsBodyPayload) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileParamsBodyPayload) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileParamsBodyPayload) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileParamsBodyPayload
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UploadLocalFileTooManyRequestsBody upload local file too many requests body
swagger:model UploadLocalFileTooManyRequestsBody
*/
type UploadLocalFileTooManyRequestsBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this upload local file too many requests body
func (o *UploadLocalFileTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this upload local file too many requests body based on context it is used
func (o *UploadLocalFileTooManyRequestsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UploadLocalFileTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UploadLocalFileTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res UploadLocalFileTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
