// Code generated by go-swagger; DO NOT EDIT.

package import_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateImportTaskReader is a Reader for the CreateImportTask structure.
type CreateImportTaskReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreateImportTaskReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewCreateImportTaskOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreateImportTaskBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewCreateImportTaskUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewCreateImportTaskForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewCreateImportTaskNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewCreateImportTaskTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewCreateImportTaskInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewCreateImportTaskDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewCreateImportTaskOK creates a CreateImportTaskOK with default headers values
func NewCreateImportTaskOK() *CreateImportTaskOK {
	return &CreateImportTaskOK{}
}

/*
CreateImportTaskOK describes a response with status code 200, with default header values.

A successful response.
*/
type CreateImportTaskOK struct {
	Payload *CreateImportTaskOKBody
}

// IsSuccess returns true when this create import task o k response has a 2xx status code
func (o *CreateImportTaskOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this create import task o k response has a 3xx status code
func (o *CreateImportTaskOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task o k response has a 4xx status code
func (o *CreateImportTaskOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this create import task o k response has a 5xx status code
func (o *CreateImportTaskOK) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task o k response a status code equal to that given
func (o *CreateImportTaskOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the create import task o k response
func (o *CreateImportTaskOK) Code() int {
	return 200
}

func (o *CreateImportTaskOK) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskOK  %+v", 200, o.Payload)
}

func (o *CreateImportTaskOK) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskOK  %+v", 200, o.Payload)
}

func (o *CreateImportTaskOK) GetPayload() *CreateImportTaskOKBody {
	return o.Payload
}

func (o *CreateImportTaskOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskBadRequest creates a CreateImportTaskBadRequest with default headers values
func NewCreateImportTaskBadRequest() *CreateImportTaskBadRequest {
	return &CreateImportTaskBadRequest{}
}

/*
CreateImportTaskBadRequest describes a response with status code 400, with default header values.

A request field is invalid.
*/
type CreateImportTaskBadRequest struct {
	Payload *CreateImportTaskBadRequestBody
}

// IsSuccess returns true when this create import task bad request response has a 2xx status code
func (o *CreateImportTaskBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task bad request response has a 3xx status code
func (o *CreateImportTaskBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task bad request response has a 4xx status code
func (o *CreateImportTaskBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task bad request response has a 5xx status code
func (o *CreateImportTaskBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task bad request response a status code equal to that given
func (o *CreateImportTaskBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the create import task bad request response
func (o *CreateImportTaskBadRequest) Code() int {
	return 400
}

func (o *CreateImportTaskBadRequest) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskBadRequest  %+v", 400, o.Payload)
}

func (o *CreateImportTaskBadRequest) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskBadRequest  %+v", 400, o.Payload)
}

func (o *CreateImportTaskBadRequest) GetPayload() *CreateImportTaskBadRequestBody {
	return o.Payload
}

func (o *CreateImportTaskBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskUnauthorized creates a CreateImportTaskUnauthorized with default headers values
func NewCreateImportTaskUnauthorized() *CreateImportTaskUnauthorized {
	return &CreateImportTaskUnauthorized{}
}

/*
CreateImportTaskUnauthorized describes a response with status code 401, with default header values.

The API key cannot be authenticated.
*/
type CreateImportTaskUnauthorized struct {
	Payload interface{}
}

// IsSuccess returns true when this create import task unauthorized response has a 2xx status code
func (o *CreateImportTaskUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task unauthorized response has a 3xx status code
func (o *CreateImportTaskUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task unauthorized response has a 4xx status code
func (o *CreateImportTaskUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task unauthorized response has a 5xx status code
func (o *CreateImportTaskUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task unauthorized response a status code equal to that given
func (o *CreateImportTaskUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the create import task unauthorized response
func (o *CreateImportTaskUnauthorized) Code() int {
	return 401
}

func (o *CreateImportTaskUnauthorized) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskUnauthorized  %+v", 401, o.Payload)
}

func (o *CreateImportTaskUnauthorized) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskUnauthorized  %+v", 401, o.Payload)
}

func (o *CreateImportTaskUnauthorized) GetPayload() interface{} {
	return o.Payload
}

func (o *CreateImportTaskUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskForbidden creates a CreateImportTaskForbidden with default headers values
func NewCreateImportTaskForbidden() *CreateImportTaskForbidden {
	return &CreateImportTaskForbidden{}
}

/*
CreateImportTaskForbidden describes a response with status code 403, with default header values.

The API key does not have permission to access the resource.
*/
type CreateImportTaskForbidden struct {
	Payload *CreateImportTaskForbiddenBody
}

// IsSuccess returns true when this create import task forbidden response has a 2xx status code
func (o *CreateImportTaskForbidden) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task forbidden response has a 3xx status code
func (o *CreateImportTaskForbidden) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task forbidden response has a 4xx status code
func (o *CreateImportTaskForbidden) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task forbidden response has a 5xx status code
func (o *CreateImportTaskForbidden) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task forbidden response a status code equal to that given
func (o *CreateImportTaskForbidden) IsCode(code int) bool {
	return code == 403
}

// Code gets the status code for the create import task forbidden response
func (o *CreateImportTaskForbidden) Code() int {
	return 403
}

func (o *CreateImportTaskForbidden) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskForbidden  %+v", 403, o.Payload)
}

func (o *CreateImportTaskForbidden) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskForbidden  %+v", 403, o.Payload)
}

func (o *CreateImportTaskForbidden) GetPayload() *CreateImportTaskForbiddenBody {
	return o.Payload
}

func (o *CreateImportTaskForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskNotFound creates a CreateImportTaskNotFound with default headers values
func NewCreateImportTaskNotFound() *CreateImportTaskNotFound {
	return &CreateImportTaskNotFound{}
}

/*
CreateImportTaskNotFound describes a response with status code 404, with default header values.

The requested resource does not exist.
*/
type CreateImportTaskNotFound struct {
	Payload *CreateImportTaskNotFoundBody
}

// IsSuccess returns true when this create import task not found response has a 2xx status code
func (o *CreateImportTaskNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task not found response has a 3xx status code
func (o *CreateImportTaskNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task not found response has a 4xx status code
func (o *CreateImportTaskNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task not found response has a 5xx status code
func (o *CreateImportTaskNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task not found response a status code equal to that given
func (o *CreateImportTaskNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the create import task not found response
func (o *CreateImportTaskNotFound) Code() int {
	return 404
}

func (o *CreateImportTaskNotFound) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskNotFound  %+v", 404, o.Payload)
}

func (o *CreateImportTaskNotFound) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskNotFound  %+v", 404, o.Payload)
}

func (o *CreateImportTaskNotFound) GetPayload() *CreateImportTaskNotFoundBody {
	return o.Payload
}

func (o *CreateImportTaskNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskTooManyRequests creates a CreateImportTaskTooManyRequests with default headers values
func NewCreateImportTaskTooManyRequests() *CreateImportTaskTooManyRequests {
	return &CreateImportTaskTooManyRequests{}
}

/*
CreateImportTaskTooManyRequests describes a response with status code 429, with default header values.

You have exceed the rate limit.
*/
type CreateImportTaskTooManyRequests struct {
	Payload *CreateImportTaskTooManyRequestsBody
}

// IsSuccess returns true when this create import task too many requests response has a 2xx status code
func (o *CreateImportTaskTooManyRequests) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task too many requests response has a 3xx status code
func (o *CreateImportTaskTooManyRequests) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task too many requests response has a 4xx status code
func (o *CreateImportTaskTooManyRequests) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task too many requests response has a 5xx status code
func (o *CreateImportTaskTooManyRequests) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task too many requests response a status code equal to that given
func (o *CreateImportTaskTooManyRequests) IsCode(code int) bool {
	return code == 429
}

// Code gets the status code for the create import task too many requests response
func (o *CreateImportTaskTooManyRequests) Code() int {
	return 429
}

func (o *CreateImportTaskTooManyRequests) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskTooManyRequests  %+v", 429, o.Payload)
}

func (o *CreateImportTaskTooManyRequests) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskTooManyRequests  %+v", 429, o.Payload)
}

func (o *CreateImportTaskTooManyRequests) GetPayload() *CreateImportTaskTooManyRequestsBody {
	return o.Payload
}

func (o *CreateImportTaskTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskInternalServerError creates a CreateImportTaskInternalServerError with default headers values
func NewCreateImportTaskInternalServerError() *CreateImportTaskInternalServerError {
	return &CreateImportTaskInternalServerError{}
}

/*
CreateImportTaskInternalServerError describes a response with status code 500, with default header values.

Server error.
*/
type CreateImportTaskInternalServerError struct {
	Payload *CreateImportTaskInternalServerErrorBody
}

// IsSuccess returns true when this create import task internal server error response has a 2xx status code
func (o *CreateImportTaskInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task internal server error response has a 3xx status code
func (o *CreateImportTaskInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task internal server error response has a 4xx status code
func (o *CreateImportTaskInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this create import task internal server error response has a 5xx status code
func (o *CreateImportTaskInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this create import task internal server error response a status code equal to that given
func (o *CreateImportTaskInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the create import task internal server error response
func (o *CreateImportTaskInternalServerError) Code() int {
	return 500
}

func (o *CreateImportTaskInternalServerError) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskInternalServerError  %+v", 500, o.Payload)
}

func (o *CreateImportTaskInternalServerError) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskInternalServerError  %+v", 500, o.Payload)
}

func (o *CreateImportTaskInternalServerError) GetPayload() *CreateImportTaskInternalServerErrorBody {
	return o.Payload
}

func (o *CreateImportTaskInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskDefault creates a CreateImportTaskDefault with default headers values
func NewCreateImportTaskDefault(code int) *CreateImportTaskDefault {
	return &CreateImportTaskDefault{
		_statusCode: code,
	}
}

/*
CreateImportTaskDefault describes a response with status code -1, with default header values.

An unexpected error response.
*/
type CreateImportTaskDefault struct {
	_statusCode int

	Payload *CreateImportTaskDefaultBody
}

// IsSuccess returns true when this create import task default response has a 2xx status code
func (o *CreateImportTaskDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this create import task default response has a 3xx status code
func (o *CreateImportTaskDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this create import task default response has a 4xx status code
func (o *CreateImportTaskDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this create import task default response has a 5xx status code
func (o *CreateImportTaskDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this create import task default response a status code equal to that given
func (o *CreateImportTaskDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the create import task default response
func (o *CreateImportTaskDefault) Code() int {
	return o._statusCode
}

func (o *CreateImportTaskDefault) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] CreateImportTask default  %+v", o._statusCode, o.Payload)
}

func (o *CreateImportTaskDefault) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] CreateImportTask default  %+v", o._statusCode, o.Payload)
}

func (o *CreateImportTaskDefault) GetPayload() *CreateImportTaskDefaultBody {
	return o.Payload
}

func (o *CreateImportTaskDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskDefaultBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
CreateImportTaskBadRequestBody create import task bad request body
swagger:model CreateImportTaskBadRequestBody
*/
type CreateImportTaskBadRequestBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task bad request body
func (o *CreateImportTaskBadRequestBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task bad request body based on context it is used
func (o *CreateImportTaskBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskBody CreateImportTaskReq
//
// CreateImportTaskReq is the request to create an import task for a cluster.
swagger:model CreateImportTaskBody
*/
type CreateImportTaskBody struct {

	// The name of an import task. The maximum length of the name is 64 characters.
	//
	// It is recommended that you use a unique name, so that you can easily identify the import task when you list all import tasks. If the name is not provided, a default name is generated with an `import_` prefix followed by a time string representing the creation time of the import task. For example, `import_2023-01-01T00:00:30Z`.
	// Example: import_2023-01-01T00:00:30Z
	// Max Length: 64
	Name string `json:"name,omitempty"`

	// options
	Options *CreateImportTaskParamsBodyOptions `json:"options,omitempty"`

	// spec
	// Required: true
	Spec *CreateImportTaskParamsBodySpec `json:"spec"`
}

// Validate validates this create import task body
func (o *CreateImportTaskBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskBody) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("body"+"."+"name", "body", o.Name, 64); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskBody) validateOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.Options) { // not required
		return nil
	}

	if o.Options != nil {
		if err := o.Options.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "options")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskBody) validateSpec(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec", "body", o.Spec); err != nil {
		return err
	}

	if o.Spec != nil {
		if err := o.Spec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create import task body based on the context it is used
func (o *CreateImportTaskBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskBody) contextValidateOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.Options != nil {

		if swag.IsZero(o.Options) { // not required
			return nil
		}

		if err := o.Options.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "options")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskBody) contextValidateSpec(ctx context.Context, formats strfmt.Registry) error {

	if o.Spec != nil {

		if err := o.Spec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskDefaultBody create import task default body
swagger:model CreateImportTaskDefaultBody
*/
type CreateImportTaskDefaultBody struct {

	// code
	Code int32 `json:"code,omitempty"`

	// details
	Details []*CreateImportTaskDefaultBodyDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task default body
func (o *CreateImportTaskDefaultBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskDefaultBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task default body based on the context it is used
func (o *CreateImportTaskDefaultBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskDefaultBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskDefaultBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskDefaultBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskDefaultBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskDefaultBodyDetailsItems0 create import task default body details items0
swagger:model CreateImportTaskDefaultBodyDetailsItems0
*/
type CreateImportTaskDefaultBodyDetailsItems0 struct {

	// at type
	AtType string `json:"@type,omitempty"`
}

// Validate validates this create import task default body details items0
func (o *CreateImportTaskDefaultBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task default body details items0 based on context it is used
func (o *CreateImportTaskDefaultBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskDefaultBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskDefaultBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskDefaultBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskForbiddenBody create import task forbidden body
swagger:model CreateImportTaskForbiddenBody
*/
type CreateImportTaskForbiddenBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task forbidden body
func (o *CreateImportTaskForbiddenBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task forbidden body based on context it is used
func (o *CreateImportTaskForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskForbiddenBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskInternalServerErrorBody create import task internal server error body
swagger:model CreateImportTaskInternalServerErrorBody
*/
type CreateImportTaskInternalServerErrorBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task internal server error body
func (o *CreateImportTaskInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task internal server error body based on context it is used
func (o *CreateImportTaskInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskNotFoundBody create import task not found body
swagger:model CreateImportTaskNotFoundBody
*/
type CreateImportTaskNotFoundBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task not found body
func (o *CreateImportTaskNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task not found body based on context it is used
func (o *CreateImportTaskNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskNotFoundBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskOKBody CreateImportTaskResp
//
// CreateImportTaskResp is the response to the creation of an import task.
swagger:model CreateImportTaskOKBody
*/
type CreateImportTaskOKBody struct {

	// The ID of the import task.
	// Example: 12345
	// Required: true
	ID *string `json:"id"`
}

// Validate validates this create import task o k body
func (o *CreateImportTaskOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskOKBody) validateID(formats strfmt.Registry) error {

	if err := validate.Required("createImportTaskOK"+"."+"id", "body", o.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task o k body based on context it is used
func (o *CreateImportTaskOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskOKBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptions CreateImportTaskOptions
//
// The additional options for creating an import task.
swagger:model CreateImportTaskParamsBodyOptions
*/
type CreateImportTaskParamsBodyOptions struct {

	// The table definition of pre-created tables.
	//
	// **Note**: The name of the pre-created tables should match one of the target tables. Otherwise, the table will be ignored and won't be created
	PreCreateTables []*CreateImportTaskParamsBodyOptionsPreCreateTablesItems0 `json:"pre_create_tables"`
}

// Validate validates this create import task params body options
func (o *CreateImportTaskParamsBodyOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePreCreateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptions) validatePreCreateTables(formats strfmt.Registry) error {
	if swag.IsZero(o.PreCreateTables) { // not required
		return nil
	}

	for i := 0; i < len(o.PreCreateTables); i++ {
		if swag.IsZero(o.PreCreateTables[i]) { // not required
			continue
		}

		if o.PreCreateTables[i] != nil {
			if err := o.PreCreateTables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task params body options based on the context it is used
func (o *CreateImportTaskParamsBodyOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePreCreateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptions) contextValidatePreCreateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PreCreateTables); i++ {

		if o.PreCreateTables[i] != nil {

			if swag.IsZero(o.PreCreateTables[i]) { // not required
				return nil
			}

			if err := o.PreCreateTables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptions) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptionsPreCreateTablesItems0 TableDefinition
//
// TableDefinition is the definition of a table so that the table can be created with this information.
swagger:model CreateImportTaskParamsBodyOptionsPreCreateTablesItems0
*/
type CreateImportTaskParamsBodyOptionsPreCreateTablesItems0 struct {

	// The database name of the table.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// schema
	// Required: true
	Schema *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema `json:"schema"`

	// The table name of the table.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this create import task params body options pre create tables items0
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSchema(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) validateSchema(formats strfmt.Registry) error {

	if err := validate.Required("schema", "body", o.Schema); err != nil {
		return err
	}

	if o.Schema != nil {
		if err := o.Schema.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create import task params body options pre create tables items0 based on the context it is used
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSchema(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) contextValidateSchema(ctx context.Context, formats strfmt.Registry) error {

	if o.Schema != nil {

		if err := o.Schema.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptionsPreCreateTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema TableSchema
//
// The schema for the table.
swagger:model CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema
*/
type CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema struct {

	// The column definition for each column in the table.
	// Example: [{"column_name":"id","column_type":"INTEGER"},{"column_name":"column01","column_type":"VARCHAR(255)"}]
	// Required: true
	ColumnDefinitions []*CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0 `json:"column_definitions"`

	// The primary key column names for the table. This is optional. The primary key is taken into account when the table is pre-created before an import task is started.
	// Example: ["id"]
	PrimaryKeyColumns []string `json:"primary_key_columns"`
}

// Validate validates this create import task params body options pre create tables items0 schema
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateColumnDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) validateColumnDefinitions(formats strfmt.Registry) error {

	if err := validate.Required("schema"+"."+"column_definitions", "body", o.ColumnDefinitions); err != nil {
		return err
	}

	for i := 0; i < len(o.ColumnDefinitions); i++ {
		if swag.IsZero(o.ColumnDefinitions[i]) { // not required
			continue
		}

		if o.ColumnDefinitions[i] != nil {
			if err := o.ColumnDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task params body options pre create tables items0 schema based on the context it is used
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateColumnDefinitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) contextValidateColumnDefinitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ColumnDefinitions); i++ {

		if o.ColumnDefinitions[i] != nil {

			if swag.IsZero(o.ColumnDefinitions[i]) { // not required
				return nil
			}

			if err := o.ColumnDefinitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0 ColumnDefinition
//
// ColumnDefinition is the definition of a column in a table.
swagger:model CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0
*/
type CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0 struct {

	// The column name.
	// Example: column01
	// Required: true
	ColumnName *string `json:"column_name"`

	// The column type.
	// Example: VARCHAR(255)
	// Required: true
	ColumnType *string `json:"column_type"`
}

// Validate validates this create import task params body options pre create tables items0 schema column definitions items0
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateColumnName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateColumnType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) validateColumnName(formats strfmt.Registry) error {

	if err := validate.Required("column_name", "body", o.ColumnName); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) validateColumnType(formats strfmt.Registry) error {

	if err := validate.Required("column_type", "body", o.ColumnType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body options pre create tables items0 schema column definitions items0 based on context it is used
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpec ImportSpec
//
// The specifications of the import task.
swagger:model CreateImportTaskParamsBodySpec
*/
type CreateImportTaskParamsBodySpec struct {

	// source
	// Required: true
	Source *CreateImportTaskParamsBodySpecSource `json:"source"`

	// target
	// Required: true
	Target *CreateImportTaskParamsBodySpecTarget `json:"target"`
}

// Validate validates this create import task params body spec
func (o *CreateImportTaskParamsBodySpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpec) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source", "body", o.Source); err != nil {
		return err
	}

	if o.Source != nil {
		if err := o.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpec) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"target", "body", o.Target); err != nil {
		return err
	}

	if o.Target != nil {
		if err := o.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create import task params body spec based on the context it is used
func (o *CreateImportTaskParamsBodySpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpec) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if o.Source != nil {

		if err := o.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpec) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if o.Target != nil {

		if err := o.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpec) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpec) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSource ImportSource
//
// The data source settings of the import task.
swagger:model CreateImportTaskParamsBodySpecSource
*/
type CreateImportTaskParamsBodySpecSource struct {

	// aws assume role access
	AwsAssumeRoleAccess *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess `json:"aws_assume_role_access,omitempty"`

	// aws key access
	AwsKeyAccess *CreateImportTaskParamsBodySpecSourceAwsKeyAccess `json:"aws_key_access,omitempty"`

	// format
	// Required: true
	Format *CreateImportTaskParamsBodySpecSourceFormat `json:"format"`

	// The data source type of an import task.
	//
	// - `"S3"`: import data from Amazon S3
	// - `"GCS"`: import data from Google Cloud Storage
	// - `"LOCAL_FILE"`: import data from a local file (only available for [TiDB Serverless](https://docs.pingcap.com/tidbcloud/select-cluster-tier#tidb-serverless) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
	//
	// **Note:** Currently, if this import spec is used for a [preview](#tag/Import/operation/PreviewImportData) request, only the `LOCAL_FILE` source type is supported.
	// Example: S3
	// Required: true
	// Enum: [S3 GCS LOCAL_FILE]
	Type *string `json:"type"`

	// The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
	// * `S3`: `s3://`
	// * `GCS`: `gs://`
	// * `LOCAL_FILE`: `file://`.
	//
	// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
	//
	// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
	// Example: s3://example-bucket/example-source-data/
	// Required: true
	URI *string `json:"uri"`
}

// Validate validates this create import task params body spec source
func (o *CreateImportTaskParamsBodySpecSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAwsAssumeRoleAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAwsKeyAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateAwsAssumeRoleAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
		return nil
	}

	if o.AwsAssumeRoleAccess != nil {
		if err := o.AwsAssumeRoleAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateAwsKeyAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsKeyAccess) { // not required
		return nil
	}

	if o.AwsKeyAccess != nil {
		if err := o.AwsKeyAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"format", "body", o.Format); err != nil {
		return err
	}

	if o.Format != nil {
		if err := o.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

var createImportTaskParamsBodySpecSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","GCS","LOCAL_FILE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createImportTaskParamsBodySpecSourceTypeTypePropEnum = append(createImportTaskParamsBodySpecSourceTypeTypePropEnum, v)
	}
}

const (

	// CreateImportTaskParamsBodySpecSourceTypeS3 captures enum value "S3"
	CreateImportTaskParamsBodySpecSourceTypeS3 string = "S3"

	// CreateImportTaskParamsBodySpecSourceTypeGCS captures enum value "GCS"
	CreateImportTaskParamsBodySpecSourceTypeGCS string = "GCS"

	// CreateImportTaskParamsBodySpecSourceTypeLOCALFILE captures enum value "LOCAL_FILE"
	CreateImportTaskParamsBodySpecSourceTypeLOCALFILE string = "LOCAL_FILE"
)

// prop value enum
func (o *CreateImportTaskParamsBodySpecSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createImportTaskParamsBodySpecSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateType(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("body"+"."+"spec"+"."+"source"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateURI(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"uri", "body", o.URI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create import task params body spec source based on the context it is used
func (o *CreateImportTaskParamsBodySpecSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAwsAssumeRoleAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAwsKeyAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) contextValidateAwsAssumeRoleAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsAssumeRoleAccess != nil {

		if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
			return nil
		}

		if err := o.AwsAssumeRoleAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) contextValidateAwsKeyAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsKeyAccess != nil {

		if swag.IsZero(o.AwsKeyAccess) { // not required
			return nil
		}

		if err := o.AwsKeyAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if o.Format != nil {

		if err := o.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSource) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSource) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess AwsAssumeRoleAccess
//
// The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess
*/
type CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess struct {

	// The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
	// Example: arn:aws:iam::999999999999:role/sample-role
	// Required: true
	AssumeRole *string `json:"assume_role"`
}

// Validate validates this create import task params body spec source aws assume role access
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssumeRole(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) validateAssumeRole(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_assume_role_access"+"."+"assume_role", "body", o.AssumeRole); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body spec source aws assume role access based on context it is used
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceAwsKeyAccess AwsKeyAccess
//
// The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model CreateImportTaskParamsBodySpecSourceAwsKeyAccess
*/
type CreateImportTaskParamsBodySpecSourceAwsKeyAccess struct {

	// The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_ACCESS_KEY_ID
	// Required: true
	AccessKeyID *string `json:"access_key_id"`

	// The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SECRET_ACCESS_KEY
	// Required: true
	SecretAccessKey *string `json:"secret_access_key"`
}

// Validate validates this create import task params body spec source aws key access
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccessKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecretAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) validateAccessKeyID(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"access_key_id", "body", o.AccessKeyID); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) validateSecretAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"secret_access_key", "body", o.SecretAccessKey); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body spec source aws key access based on context it is used
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceAwsKeyAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceFormat ImportSourceFormat
//
// The format settings of the import data source.
swagger:model CreateImportTaskParamsBodySpecSourceFormat
*/
type CreateImportTaskParamsBodySpecSourceFormat struct {

	// csv config
	CsvConfig *CreateImportTaskParamsBodySpecSourceFormatCsvConfig `json:"csv_config,omitempty"`

	// The format type of an import source.
	// Example: CSV
	// Required: true
	// Enum: [CSV PARQUET SQL AURORA_SNAPSHOT]
	Type *string `json:"type"`
}

// Validate validates this create import task params body spec source format
func (o *CreateImportTaskParamsBodySpecSourceFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCsvConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceFormat) validateCsvConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.CsvConfig) { // not required
		return nil
	}

	if o.CsvConfig != nil {
		if err := o.CsvConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

var createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum = append(createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum, v)
	}
}

const (

	// CreateImportTaskParamsBodySpecSourceFormatTypeCSV captures enum value "CSV"
	CreateImportTaskParamsBodySpecSourceFormatTypeCSV string = "CSV"

	// CreateImportTaskParamsBodySpecSourceFormatTypePARQUET captures enum value "PARQUET"
	CreateImportTaskParamsBodySpecSourceFormatTypePARQUET string = "PARQUET"

	// CreateImportTaskParamsBodySpecSourceFormatTypeSQL captures enum value "SQL"
	CreateImportTaskParamsBodySpecSourceFormatTypeSQL string = "SQL"

	// CreateImportTaskParamsBodySpecSourceFormatTypeAURORASNAPSHOT captures enum value "AURORA_SNAPSHOT"
	CreateImportTaskParamsBodySpecSourceFormatTypeAURORASNAPSHOT string = "AURORA_SNAPSHOT"
)

// prop value enum
func (o *CreateImportTaskParamsBodySpecSourceFormat) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceFormat) validateType(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("body"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create import task params body spec source format based on the context it is used
func (o *CreateImportTaskParamsBodySpecSourceFormat) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCsvConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceFormat) contextValidateCsvConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.CsvConfig != nil {

		if swag.IsZero(o.CsvConfig) { // not required
			return nil
		}

		if err := o.CsvConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormat) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormat) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceFormatCsvConfig ImportSourceCSVConfig
//
// The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
swagger:model CreateImportTaskParamsBodySpecSourceFormatCsvConfig
*/
type CreateImportTaskParamsBodySpecSourceFormatCsvConfig struct {

	// Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
	//
	// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
	BackslashEscape *bool `json:"backslash_escape,omitempty"`

	// The delimiter character used to separate fields in the CSV data.
	Delimiter *string `json:"delimiter,omitempty"`

	// Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
	HasHeaderRow *bool `json:"has_header_row,omitempty"`

	// The character used to quote the fields in the CSV data.
	Quote *string `json:"quote,omitempty"`
}

// Validate validates this create import task params body spec source format csv config
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task params body spec source format csv config based on context it is used
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceFormatCsvConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecTarget ImportTarget
//
// The target settings of the import task.
swagger:model CreateImportTaskParamsBodySpecTarget
*/
type CreateImportTaskParamsBodySpecTarget struct {

	// The settings for each target table that is being imported for the import task. If you leave it empty, the system will scan all the files in the data source using the default file patterns and collect all the tables to import. The files include data files, table schema files, and DB schema files. If you provide a list of tables, only those tables will be imported. For more information about the default file pattern, see [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Limitations:**
	// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
	// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
	// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
	Tables []*CreateImportTaskParamsBodySpecTargetTablesItems0 `json:"tables"`
}

// Validate validates this create import task params body spec target
func (o *CreateImportTaskParamsBodySpecTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecTarget) validateTables(formats strfmt.Registry) error {
	if swag.IsZero(o.Tables) { // not required
		return nil
	}

	for i := 0; i < len(o.Tables); i++ {
		if swag.IsZero(o.Tables[i]) { // not required
			continue
		}

		if o.Tables[i] != nil {
			if err := o.Tables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task params body spec target based on the context it is used
func (o *CreateImportTaskParamsBodySpecTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecTarget) contextValidateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Tables); i++ {

		if o.Tables[i] != nil {

			if swag.IsZero(o.Tables[i]) { // not required
				return nil
			}

			if err := o.Tables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTarget) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTarget) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecTargetTablesItems0 ImportTargetTable
//
// ImportTargetTable represents the settings for importing source data into a single target table of an import task.
swagger:model CreateImportTaskParamsBodySpecTargetTablesItems0
*/
type CreateImportTaskParamsBodySpecTargetTablesItems0 struct {

	// The target database name.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
	// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
	// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
	//
	// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
	//
	// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
	//
	// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
	// Example: data/db01/table01.*.csv
	FileNamePattern string `json:"file_name_pattern,omitempty"`

	// The target table name.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this create import task params body spec target tables items0
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body spec target tables items0 based on context it is used
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecTargetTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskTooManyRequestsBody create import task too many requests body
swagger:model CreateImportTaskTooManyRequestsBody
*/
type CreateImportTaskTooManyRequestsBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task too many requests body
func (o *CreateImportTaskTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task too many requests body based on context it is used
func (o *CreateImportTaskTooManyRequestsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
