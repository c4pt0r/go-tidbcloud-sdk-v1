// Code generated by go-swagger; DO NOT EDIT.

package import_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateImportTaskReader is a Reader for the CreateImportTask structure.
type CreateImportTaskReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreateImportTaskReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewCreateImportTaskOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreateImportTaskBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewCreateImportTaskUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewCreateImportTaskForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewCreateImportTaskNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewCreateImportTaskTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewCreateImportTaskInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewCreateImportTaskDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewCreateImportTaskOK creates a CreateImportTaskOK with default headers values
func NewCreateImportTaskOK() *CreateImportTaskOK {
	return &CreateImportTaskOK{}
}

/*
CreateImportTaskOK describes a response with status code 200, with default header values.

A successful response.
*/
type CreateImportTaskOK struct {
	Payload *CreateImportTaskOKBody
}

// IsSuccess returns true when this create import task o k response has a 2xx status code
func (o *CreateImportTaskOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this create import task o k response has a 3xx status code
func (o *CreateImportTaskOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task o k response has a 4xx status code
func (o *CreateImportTaskOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this create import task o k response has a 5xx status code
func (o *CreateImportTaskOK) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task o k response a status code equal to that given
func (o *CreateImportTaskOK) IsCode(code int) bool {
	return code == 200
}

func (o *CreateImportTaskOK) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskOK  %+v", 200, o.Payload)
}

func (o *CreateImportTaskOK) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskOK  %+v", 200, o.Payload)
}

func (o *CreateImportTaskOK) GetPayload() *CreateImportTaskOKBody {
	return o.Payload
}

func (o *CreateImportTaskOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskBadRequest creates a CreateImportTaskBadRequest with default headers values
func NewCreateImportTaskBadRequest() *CreateImportTaskBadRequest {
	return &CreateImportTaskBadRequest{}
}

/*
CreateImportTaskBadRequest describes a response with status code 400, with default header values.

A request field is invalid.
*/
type CreateImportTaskBadRequest struct {
	Payload *CreateImportTaskBadRequestBody
}

// IsSuccess returns true when this create import task bad request response has a 2xx status code
func (o *CreateImportTaskBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task bad request response has a 3xx status code
func (o *CreateImportTaskBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task bad request response has a 4xx status code
func (o *CreateImportTaskBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task bad request response has a 5xx status code
func (o *CreateImportTaskBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task bad request response a status code equal to that given
func (o *CreateImportTaskBadRequest) IsCode(code int) bool {
	return code == 400
}

func (o *CreateImportTaskBadRequest) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskBadRequest  %+v", 400, o.Payload)
}

func (o *CreateImportTaskBadRequest) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskBadRequest  %+v", 400, o.Payload)
}

func (o *CreateImportTaskBadRequest) GetPayload() *CreateImportTaskBadRequestBody {
	return o.Payload
}

func (o *CreateImportTaskBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskUnauthorized creates a CreateImportTaskUnauthorized with default headers values
func NewCreateImportTaskUnauthorized() *CreateImportTaskUnauthorized {
	return &CreateImportTaskUnauthorized{}
}

/*
CreateImportTaskUnauthorized describes a response with status code 401, with default header values.

The API key cannot be authenticated.
*/
type CreateImportTaskUnauthorized struct {
	Payload interface{}
}

// IsSuccess returns true when this create import task unauthorized response has a 2xx status code
func (o *CreateImportTaskUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task unauthorized response has a 3xx status code
func (o *CreateImportTaskUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task unauthorized response has a 4xx status code
func (o *CreateImportTaskUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task unauthorized response has a 5xx status code
func (o *CreateImportTaskUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task unauthorized response a status code equal to that given
func (o *CreateImportTaskUnauthorized) IsCode(code int) bool {
	return code == 401
}

func (o *CreateImportTaskUnauthorized) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskUnauthorized  %+v", 401, o.Payload)
}

func (o *CreateImportTaskUnauthorized) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskUnauthorized  %+v", 401, o.Payload)
}

func (o *CreateImportTaskUnauthorized) GetPayload() interface{} {
	return o.Payload
}

func (o *CreateImportTaskUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskForbidden creates a CreateImportTaskForbidden with default headers values
func NewCreateImportTaskForbidden() *CreateImportTaskForbidden {
	return &CreateImportTaskForbidden{}
}

/*
CreateImportTaskForbidden describes a response with status code 403, with default header values.

The API key does not have permission to access the resource.
*/
type CreateImportTaskForbidden struct {
	Payload *CreateImportTaskForbiddenBody
}

// IsSuccess returns true when this create import task forbidden response has a 2xx status code
func (o *CreateImportTaskForbidden) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task forbidden response has a 3xx status code
func (o *CreateImportTaskForbidden) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task forbidden response has a 4xx status code
func (o *CreateImportTaskForbidden) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task forbidden response has a 5xx status code
func (o *CreateImportTaskForbidden) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task forbidden response a status code equal to that given
func (o *CreateImportTaskForbidden) IsCode(code int) bool {
	return code == 403
}

func (o *CreateImportTaskForbidden) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskForbidden  %+v", 403, o.Payload)
}

func (o *CreateImportTaskForbidden) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskForbidden  %+v", 403, o.Payload)
}

func (o *CreateImportTaskForbidden) GetPayload() *CreateImportTaskForbiddenBody {
	return o.Payload
}

func (o *CreateImportTaskForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskNotFound creates a CreateImportTaskNotFound with default headers values
func NewCreateImportTaskNotFound() *CreateImportTaskNotFound {
	return &CreateImportTaskNotFound{}
}

/*
CreateImportTaskNotFound describes a response with status code 404, with default header values.

The requested resource does not exist.
*/
type CreateImportTaskNotFound struct {
	Payload *CreateImportTaskNotFoundBody
}

// IsSuccess returns true when this create import task not found response has a 2xx status code
func (o *CreateImportTaskNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task not found response has a 3xx status code
func (o *CreateImportTaskNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task not found response has a 4xx status code
func (o *CreateImportTaskNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task not found response has a 5xx status code
func (o *CreateImportTaskNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task not found response a status code equal to that given
func (o *CreateImportTaskNotFound) IsCode(code int) bool {
	return code == 404
}

func (o *CreateImportTaskNotFound) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskNotFound  %+v", 404, o.Payload)
}

func (o *CreateImportTaskNotFound) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskNotFound  %+v", 404, o.Payload)
}

func (o *CreateImportTaskNotFound) GetPayload() *CreateImportTaskNotFoundBody {
	return o.Payload
}

func (o *CreateImportTaskNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskTooManyRequests creates a CreateImportTaskTooManyRequests with default headers values
func NewCreateImportTaskTooManyRequests() *CreateImportTaskTooManyRequests {
	return &CreateImportTaskTooManyRequests{}
}

/*
CreateImportTaskTooManyRequests describes a response with status code 429, with default header values.

You have exceed the rate limit.
*/
type CreateImportTaskTooManyRequests struct {
	Payload *CreateImportTaskTooManyRequestsBody
}

// IsSuccess returns true when this create import task too many requests response has a 2xx status code
func (o *CreateImportTaskTooManyRequests) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task too many requests response has a 3xx status code
func (o *CreateImportTaskTooManyRequests) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task too many requests response has a 4xx status code
func (o *CreateImportTaskTooManyRequests) IsClientError() bool {
	return true
}

// IsServerError returns true when this create import task too many requests response has a 5xx status code
func (o *CreateImportTaskTooManyRequests) IsServerError() bool {
	return false
}

// IsCode returns true when this create import task too many requests response a status code equal to that given
func (o *CreateImportTaskTooManyRequests) IsCode(code int) bool {
	return code == 429
}

func (o *CreateImportTaskTooManyRequests) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskTooManyRequests  %+v", 429, o.Payload)
}

func (o *CreateImportTaskTooManyRequests) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskTooManyRequests  %+v", 429, o.Payload)
}

func (o *CreateImportTaskTooManyRequests) GetPayload() *CreateImportTaskTooManyRequestsBody {
	return o.Payload
}

func (o *CreateImportTaskTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskInternalServerError creates a CreateImportTaskInternalServerError with default headers values
func NewCreateImportTaskInternalServerError() *CreateImportTaskInternalServerError {
	return &CreateImportTaskInternalServerError{}
}

/*
CreateImportTaskInternalServerError describes a response with status code 500, with default header values.

Server error.
*/
type CreateImportTaskInternalServerError struct {
	Payload *CreateImportTaskInternalServerErrorBody
}

// IsSuccess returns true when this create import task internal server error response has a 2xx status code
func (o *CreateImportTaskInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create import task internal server error response has a 3xx status code
func (o *CreateImportTaskInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create import task internal server error response has a 4xx status code
func (o *CreateImportTaskInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this create import task internal server error response has a 5xx status code
func (o *CreateImportTaskInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this create import task internal server error response a status code equal to that given
func (o *CreateImportTaskInternalServerError) IsCode(code int) bool {
	return code == 500
}

func (o *CreateImportTaskInternalServerError) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskInternalServerError  %+v", 500, o.Payload)
}

func (o *CreateImportTaskInternalServerError) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] createImportTaskInternalServerError  %+v", 500, o.Payload)
}

func (o *CreateImportTaskInternalServerError) GetPayload() *CreateImportTaskInternalServerErrorBody {
	return o.Payload
}

func (o *CreateImportTaskInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateImportTaskDefault creates a CreateImportTaskDefault with default headers values
func NewCreateImportTaskDefault(code int) *CreateImportTaskDefault {
	return &CreateImportTaskDefault{
		_statusCode: code,
	}
}

/*
CreateImportTaskDefault describes a response with status code -1, with default header values.

An unexpected error response.
*/
type CreateImportTaskDefault struct {
	_statusCode int

	Payload *CreateImportTaskDefaultBody
}

// Code gets the status code for the create import task default response
func (o *CreateImportTaskDefault) Code() int {
	return o._statusCode
}

// IsSuccess returns true when this create import task default response has a 2xx status code
func (o *CreateImportTaskDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this create import task default response has a 3xx status code
func (o *CreateImportTaskDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this create import task default response has a 4xx status code
func (o *CreateImportTaskDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this create import task default response has a 5xx status code
func (o *CreateImportTaskDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this create import task default response a status code equal to that given
func (o *CreateImportTaskDefault) IsCode(code int) bool {
	return o._statusCode == code
}

func (o *CreateImportTaskDefault) Error() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] CreateImportTask default  %+v", o._statusCode, o.Payload)
}

func (o *CreateImportTaskDefault) String() string {
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] CreateImportTask default  %+v", o._statusCode, o.Payload)
}

func (o *CreateImportTaskDefault) GetPayload() *CreateImportTaskDefaultBody {
	return o.Payload
}

func (o *CreateImportTaskDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateImportTaskDefaultBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
CreateImportTaskBadRequestBody create import task bad request body
swagger:model CreateImportTaskBadRequestBody
*/
type CreateImportTaskBadRequestBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task bad request body
func (o *CreateImportTaskBadRequestBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task bad request body based on context it is used
func (o *CreateImportTaskBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskBody CreateImportTaskReq
//
// CreateImportTaskReq is the request to create an import task for a cluster.
swagger:model CreateImportTaskBody
*/
type CreateImportTaskBody struct {

	// The name of an import task. The maximum length of the name is 64 characters.
	//
	// It is recommended that you use a unique name, so that you can easily identify the import task when you list all import tasks. If the name is not provided, a default name is generated with an `import_` prefix followed by a time string representing the creation time of the import task. For example, `import_2023-01-01T00:00:30Z`.
	// Example: import_2023-01-01T00:00:30Z
	// Max Length: 64
	Name string `json:"name,omitempty"`

	// options
	Options *CreateImportTaskParamsBodyOptions `json:"options,omitempty"`

	// spec
	// Required: true
	Spec *CreateImportTaskParamsBodySpec `json:"spec"`
}

// Validate validates this create import task body
func (o *CreateImportTaskBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskBody) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("body"+"."+"name", "body", o.Name, 64); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskBody) validateOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.Options) { // not required
		return nil
	}

	if o.Options != nil {
		if err := o.Options.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "options")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskBody) validateSpec(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec", "body", o.Spec); err != nil {
		return err
	}

	if o.Spec != nil {
		if err := o.Spec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create import task body based on the context it is used
func (o *CreateImportTaskBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskBody) contextValidateOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.Options != nil {
		if err := o.Options.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "options")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskBody) contextValidateSpec(ctx context.Context, formats strfmt.Registry) error {

	if o.Spec != nil {
		if err := o.Spec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskDefaultBody create import task default body
swagger:model CreateImportTaskDefaultBody
*/
type CreateImportTaskDefaultBody struct {

	// code
	Code int32 `json:"code,omitempty"`

	// details
	Details []*CreateImportTaskDefaultBodyDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task default body
func (o *CreateImportTaskDefaultBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskDefaultBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task default body based on the context it is used
func (o *CreateImportTaskDefaultBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskDefaultBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("CreateImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskDefaultBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskDefaultBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskDefaultBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskDefaultBodyDetailsItems0 create import task default body details items0
swagger:model CreateImportTaskDefaultBodyDetailsItems0
*/
type CreateImportTaskDefaultBodyDetailsItems0 struct {

	// at type
	AtType string `json:"@type,omitempty"`
}

// Validate validates this create import task default body details items0
func (o *CreateImportTaskDefaultBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task default body details items0 based on context it is used
func (o *CreateImportTaskDefaultBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskDefaultBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskDefaultBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskDefaultBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskForbiddenBody create import task forbidden body
swagger:model CreateImportTaskForbiddenBody
*/
type CreateImportTaskForbiddenBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task forbidden body
func (o *CreateImportTaskForbiddenBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task forbidden body based on context it is used
func (o *CreateImportTaskForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskForbiddenBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskInternalServerErrorBody create import task internal server error body
swagger:model CreateImportTaskInternalServerErrorBody
*/
type CreateImportTaskInternalServerErrorBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task internal server error body
func (o *CreateImportTaskInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task internal server error body based on context it is used
func (o *CreateImportTaskInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskNotFoundBody create import task not found body
swagger:model CreateImportTaskNotFoundBody
*/
type CreateImportTaskNotFoundBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task not found body
func (o *CreateImportTaskNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task not found body based on context it is used
func (o *CreateImportTaskNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskNotFoundBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskOKBody CreateImportTaskResp
//
// CreateImportTaskResp is the response to the creation of an import task.
swagger:model CreateImportTaskOKBody
*/
type CreateImportTaskOKBody struct {

	// The ID of the import task.
	// Example: 12345
	// Required: true
	ID *string `json:"id"`
}

// Validate validates this create import task o k body
func (o *CreateImportTaskOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskOKBody) validateID(formats strfmt.Registry) error {

	if err := validate.Required("createImportTaskOK"+"."+"id", "body", o.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task o k body based on context it is used
func (o *CreateImportTaskOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskOKBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptions CreateImportTaskOptions
//
// The additional options for creating an import task.
swagger:model CreateImportTaskParamsBodyOptions
*/
type CreateImportTaskParamsBodyOptions struct {

	// The table definition of pre-created tables.
	//
	// **Note**: The name of the pre-created tables should match one of the target tables. Otherwise, the table will be ignored and won't be created
	PreCreateTables []*CreateImportTaskParamsBodyOptionsPreCreateTablesItems0 `json:"pre_create_tables"`
}

// Validate validates this create import task params body options
func (o *CreateImportTaskParamsBodyOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePreCreateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptions) validatePreCreateTables(formats strfmt.Registry) error {
	if swag.IsZero(o.PreCreateTables) { // not required
		return nil
	}

	for i := 0; i < len(o.PreCreateTables); i++ {
		if swag.IsZero(o.PreCreateTables[i]) { // not required
			continue
		}

		if o.PreCreateTables[i] != nil {
			if err := o.PreCreateTables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task params body options based on the context it is used
func (o *CreateImportTaskParamsBodyOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePreCreateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptions) contextValidatePreCreateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PreCreateTables); i++ {

		if o.PreCreateTables[i] != nil {
			if err := o.PreCreateTables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "options" + "." + "pre_create_tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptions) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptionsPreCreateTablesItems0 TableDefinition
//
// TableDefinition is the definition of a table so that the table can be created with this information.
swagger:model CreateImportTaskParamsBodyOptionsPreCreateTablesItems0
*/
type CreateImportTaskParamsBodyOptionsPreCreateTablesItems0 struct {

	// The database name of the table.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// schema
	// Required: true
	Schema *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema `json:"schema"`

	// The table name of the table.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this create import task params body options pre create tables items0
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSchema(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) validateSchema(formats strfmt.Registry) error {

	if err := validate.Required("schema", "body", o.Schema); err != nil {
		return err
	}

	if o.Schema != nil {
		if err := o.Schema.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create import task params body options pre create tables items0 based on the context it is used
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSchema(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) contextValidateSchema(ctx context.Context, formats strfmt.Registry) error {

	if o.Schema != nil {
		if err := o.Schema.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptionsPreCreateTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema TableSchema
//
// The schema for the table.
swagger:model CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema
*/
type CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema struct {

	// The column definition for each column in the table.
	// Example: [{"column_name":"id","column_type":"INTEGER"},{"column_name":"column01","column_type":"VARCHAR(255)"}]
	// Required: true
	ColumnDefinitions []*CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0 `json:"column_definitions"`

	// The primary key column names for the table. This is optional. The primary key is taken into account when the table is pre-created before an import task is started.
	// Example: ["id"]
	PrimaryKeyColumns []string `json:"primary_key_columns"`
}

// Validate validates this create import task params body options pre create tables items0 schema
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateColumnDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) validateColumnDefinitions(formats strfmt.Registry) error {

	if err := validate.Required("schema"+"."+"column_definitions", "body", o.ColumnDefinitions); err != nil {
		return err
	}

	for i := 0; i < len(o.ColumnDefinitions); i++ {
		if swag.IsZero(o.ColumnDefinitions[i]) { // not required
			continue
		}

		if o.ColumnDefinitions[i] != nil {
			if err := o.ColumnDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task params body options pre create tables items0 schema based on the context it is used
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateColumnDefinitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) contextValidateColumnDefinitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ColumnDefinitions); i++ {

		if o.ColumnDefinitions[i] != nil {
			if err := o.ColumnDefinitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schema" + "." + "column_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptionsPreCreateTablesItems0Schema
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0 ColumnDefinition
//
// ColumnDefinition is the definition of a column in a table.
swagger:model CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0
*/
type CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0 struct {

	// The column name.
	// Example: column01
	// Required: true
	ColumnName *string `json:"column_name"`

	// The column type.
	// Example: VARCHAR(255)
	// Required: true
	ColumnType *string `json:"column_type"`
}

// Validate validates this create import task params body options pre create tables items0 schema column definitions items0
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateColumnName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateColumnType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) validateColumnName(formats strfmt.Registry) error {

	if err := validate.Required("column_name", "body", o.ColumnName); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) validateColumnType(formats strfmt.Registry) error {

	if err := validate.Required("column_type", "body", o.ColumnType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body options pre create tables items0 schema column definitions items0 based on context it is used
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodyOptionsPreCreateTablesItems0SchemaColumnDefinitionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpec ImportSpec
//
// The specifications of the import task.
swagger:model CreateImportTaskParamsBodySpec
*/
type CreateImportTaskParamsBodySpec struct {

	// source
	// Required: true
	Source *CreateImportTaskParamsBodySpecSource `json:"source"`

	// target
	// Required: true
	Target *CreateImportTaskParamsBodySpecTarget `json:"target"`
}

// Validate validates this create import task params body spec
func (o *CreateImportTaskParamsBodySpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpec) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source", "body", o.Source); err != nil {
		return err
	}

	if o.Source != nil {
		if err := o.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpec) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"target", "body", o.Target); err != nil {
		return err
	}

	if o.Target != nil {
		if err := o.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create import task params body spec based on the context it is used
func (o *CreateImportTaskParamsBodySpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpec) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if o.Source != nil {
		if err := o.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpec) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if o.Target != nil {
		if err := o.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpec) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpec) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSource ImportSource
//
// The data source settings of the import task.
swagger:model CreateImportTaskParamsBodySpecSource
*/
type CreateImportTaskParamsBodySpecSource struct {

	// aws assume role access
	AwsAssumeRoleAccess *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess `json:"aws_assume_role_access,omitempty"`

	// aws key access
	AwsKeyAccess *CreateImportTaskParamsBodySpecSourceAwsKeyAccess `json:"aws_key_access,omitempty"`

	// format
	// Required: true
	Format *CreateImportTaskParamsBodySpecSourceFormat `json:"format"`

	// The data source type of an import task.
	//
	// - `"S3"`: import data from Amazon S3
	// - `"GCS"`: import data from Google Cloud Storage
	// - `"LOCAL_FILE"`: import data from a local file (only available for [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier-beta) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
	// Example: S3
	// Required: true
	// Enum: [S3 GCS LOCAL_FILE]
	Type *string `json:"type"`

	// The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
	// * `S3`: `s3://`
	// * `GCS`: `gs://`
	// * `LOCAL_FILE`: `file://`.
	//
	// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
	//
	// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
	// Example: s3://example-bucket/example-source-data/
	// Required: true
	URI *string `json:"uri"`
}

// Validate validates this create import task params body spec source
func (o *CreateImportTaskParamsBodySpecSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAwsAssumeRoleAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAwsKeyAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateAwsAssumeRoleAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
		return nil
	}

	if o.AwsAssumeRoleAccess != nil {
		if err := o.AwsAssumeRoleAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateAwsKeyAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsKeyAccess) { // not required
		return nil
	}

	if o.AwsKeyAccess != nil {
		if err := o.AwsKeyAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"format", "body", o.Format); err != nil {
		return err
	}

	if o.Format != nil {
		if err := o.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

var createImportTaskParamsBodySpecSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","GCS","LOCAL_FILE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createImportTaskParamsBodySpecSourceTypeTypePropEnum = append(createImportTaskParamsBodySpecSourceTypeTypePropEnum, v)
	}
}

const (

	// CreateImportTaskParamsBodySpecSourceTypeS3 captures enum value "S3"
	CreateImportTaskParamsBodySpecSourceTypeS3 string = "S3"

	// CreateImportTaskParamsBodySpecSourceTypeGCS captures enum value "GCS"
	CreateImportTaskParamsBodySpecSourceTypeGCS string = "GCS"

	// CreateImportTaskParamsBodySpecSourceTypeLOCALFILE captures enum value "LOCAL_FILE"
	CreateImportTaskParamsBodySpecSourceTypeLOCALFILE string = "LOCAL_FILE"
)

// prop value enum
func (o *CreateImportTaskParamsBodySpecSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createImportTaskParamsBodySpecSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateType(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("body"+"."+"spec"+"."+"source"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) validateURI(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"uri", "body", o.URI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create import task params body spec source based on the context it is used
func (o *CreateImportTaskParamsBodySpecSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAwsAssumeRoleAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAwsKeyAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) contextValidateAwsAssumeRoleAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsAssumeRoleAccess != nil {
		if err := o.AwsAssumeRoleAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) contextValidateAwsKeyAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsKeyAccess != nil {
		if err := o.AwsKeyAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSource) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if o.Format != nil {
		if err := o.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSource) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSource) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess AwsAssumeRoleAccess
//
// The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess
*/
type CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess struct {

	// The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
	// Example: arn:aws:iam::999999999999:role/sample-role
	// Required: true
	AssumeRole *string `json:"assume_role"`
}

// Validate validates this create import task params body spec source aws assume role access
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssumeRole(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) validateAssumeRole(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_assume_role_access"+"."+"assume_role", "body", o.AssumeRole); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body spec source aws assume role access based on context it is used
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceAwsAssumeRoleAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceAwsKeyAccess AwsKeyAccess
//
// The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model CreateImportTaskParamsBodySpecSourceAwsKeyAccess
*/
type CreateImportTaskParamsBodySpecSourceAwsKeyAccess struct {

	// The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_ACCESS_KEY_ID
	// Required: true
	AccessKeyID *string `json:"access_key_id"`

	// The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SECRET_ACCESS_KEY
	// Required: true
	SecretAccessKey *string `json:"secret_access_key"`
}

// Validate validates this create import task params body spec source aws key access
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccessKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecretAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) validateAccessKeyID(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"access_key_id", "body", o.AccessKeyID); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) validateSecretAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"secret_access_key", "body", o.SecretAccessKey); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body spec source aws key access based on context it is used
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceAwsKeyAccess) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceAwsKeyAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceFormat ImportSourceFormat
//
// The format settings of the import data source.
swagger:model CreateImportTaskParamsBodySpecSourceFormat
*/
type CreateImportTaskParamsBodySpecSourceFormat struct {

	// csv config
	CsvConfig *CreateImportTaskParamsBodySpecSourceFormatCsvConfig `json:"csv_config,omitempty"`

	// The format type of an import source.
	// Example: CSV
	// Required: true
	// Enum: [CSV PARQUET SQL AURORA_SNAPSHOT]
	Type *string `json:"type"`
}

// Validate validates this create import task params body spec source format
func (o *CreateImportTaskParamsBodySpecSourceFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCsvConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceFormat) validateCsvConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.CsvConfig) { // not required
		return nil
	}

	if o.CsvConfig != nil {
		if err := o.CsvConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

var createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum = append(createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum, v)
	}
}

const (

	// CreateImportTaskParamsBodySpecSourceFormatTypeCSV captures enum value "CSV"
	CreateImportTaskParamsBodySpecSourceFormatTypeCSV string = "CSV"

	// CreateImportTaskParamsBodySpecSourceFormatTypePARQUET captures enum value "PARQUET"
	CreateImportTaskParamsBodySpecSourceFormatTypePARQUET string = "PARQUET"

	// CreateImportTaskParamsBodySpecSourceFormatTypeSQL captures enum value "SQL"
	CreateImportTaskParamsBodySpecSourceFormatTypeSQL string = "SQL"

	// CreateImportTaskParamsBodySpecSourceFormatTypeAURORASNAPSHOT captures enum value "AURORA_SNAPSHOT"
	CreateImportTaskParamsBodySpecSourceFormatTypeAURORASNAPSHOT string = "AURORA_SNAPSHOT"
)

// prop value enum
func (o *CreateImportTaskParamsBodySpecSourceFormat) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createImportTaskParamsBodySpecSourceFormatTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceFormat) validateType(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("body"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create import task params body spec source format based on the context it is used
func (o *CreateImportTaskParamsBodySpecSourceFormat) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCsvConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecSourceFormat) contextValidateCsvConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.CsvConfig != nil {
		if err := o.CsvConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormat) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormat) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecSourceFormatCsvConfig ImportSourceCSVConfig
//
// The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
swagger:model CreateImportTaskParamsBodySpecSourceFormatCsvConfig
*/
type CreateImportTaskParamsBodySpecSourceFormatCsvConfig struct {

	// Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
	//
	// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
	BackslashEscape *bool `json:"backslash_escape,omitempty"`

	// The delimiter character used to separate fields in the CSV data.
	Delimiter *string `json:"delimiter,omitempty"`

	// Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
	HasHeaderRow *bool `json:"has_header_row,omitempty"`

	// The character used to quote the fields in the CSV data.
	Quote *string `json:"quote,omitempty"`
}

// Validate validates this create import task params body spec source format csv config
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task params body spec source format csv config based on context it is used
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecSourceFormatCsvConfig) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecSourceFormatCsvConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecTarget ImportTarget
//
// The target settings of the import task.
swagger:model CreateImportTaskParamsBodySpecTarget
*/
type CreateImportTaskParamsBodySpecTarget struct {

	// The settings for each target table that is being imported for the import task.
	//
	// **Limitations:**
	// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
	// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
	// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
	Tables []*CreateImportTaskParamsBodySpecTargetTablesItems0 `json:"tables"`
}

// Validate validates this create import task params body spec target
func (o *CreateImportTaskParamsBodySpecTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecTarget) validateTables(formats strfmt.Registry) error {
	if swag.IsZero(o.Tables) { // not required
		return nil
	}

	for i := 0; i < len(o.Tables); i++ {
		if swag.IsZero(o.Tables[i]) { // not required
			continue
		}

		if o.Tables[i] != nil {
			if err := o.Tables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create import task params body spec target based on the context it is used
func (o *CreateImportTaskParamsBodySpecTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecTarget) contextValidateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Tables); i++ {

		if o.Tables[i] != nil {
			if err := o.Tables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTarget) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTarget) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskParamsBodySpecTargetTablesItems0 ImportTargetTable
//
// ImportTargetTable represents the settings for importing source data into a single target table of an import task.
swagger:model CreateImportTaskParamsBodySpecTargetTablesItems0
*/
type CreateImportTaskParamsBodySpecTargetTablesItems0 struct {

	// The target database name.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
	// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
	// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
	//
	// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
	//
	// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
	//
	// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
	// Example: data/db01/table01.*.csv
	FileNamePattern string `json:"file_name_pattern,omitempty"`

	// The target table name.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this create import task params body spec target tables items0
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create import task params body spec target tables items0 based on context it is used
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskParamsBodySpecTargetTablesItems0) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskParamsBodySpecTargetTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateImportTaskTooManyRequestsBody create import task too many requests body
swagger:model CreateImportTaskTooManyRequestsBody
*/
type CreateImportTaskTooManyRequestsBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this create import task too many requests body
func (o *CreateImportTaskTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create import task too many requests body based on context it is used
func (o *CreateImportTaskTooManyRequestsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateImportTaskTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateImportTaskTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res CreateImportTaskTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
