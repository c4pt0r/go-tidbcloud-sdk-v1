// Code generated by go-swagger; DO NOT EDIT.

package import_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PreviewImportDataReader is a Reader for the PreviewImportData structure.
type PreviewImportDataReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PreviewImportDataReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPreviewImportDataOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPreviewImportDataBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewPreviewImportDataUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPreviewImportDataForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPreviewImportDataNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewPreviewImportDataTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewPreviewImportDataInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPreviewImportDataDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPreviewImportDataOK creates a PreviewImportDataOK with default headers values
func NewPreviewImportDataOK() *PreviewImportDataOK {
	return &PreviewImportDataOK{}
}

/*
PreviewImportDataOK describes a response with status code 200, with default header values.

A successful response.
*/
type PreviewImportDataOK struct {
	Payload *PreviewImportDataOKBody
}

// IsSuccess returns true when this preview import data o k response has a 2xx status code
func (o *PreviewImportDataOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this preview import data o k response has a 3xx status code
func (o *PreviewImportDataOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this preview import data o k response has a 4xx status code
func (o *PreviewImportDataOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this preview import data o k response has a 5xx status code
func (o *PreviewImportDataOK) IsServerError() bool {
	return false
}

// IsCode returns true when this preview import data o k response a status code equal to that given
func (o *PreviewImportDataOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the preview import data o k response
func (o *PreviewImportDataOK) Code() int {
	return 200
}

func (o *PreviewImportDataOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataOK %s", 200, payload)
}

func (o *PreviewImportDataOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataOK %s", 200, payload)
}

func (o *PreviewImportDataOK) GetPayload() *PreviewImportDataOKBody {
	return o.Payload
}

func (o *PreviewImportDataOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PreviewImportDataOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPreviewImportDataBadRequest creates a PreviewImportDataBadRequest with default headers values
func NewPreviewImportDataBadRequest() *PreviewImportDataBadRequest {
	return &PreviewImportDataBadRequest{}
}

/*
PreviewImportDataBadRequest describes a response with status code 400, with default header values.

A request field is invalid.
*/
type PreviewImportDataBadRequest struct {
	Payload *PreviewImportDataBadRequestBody
}

// IsSuccess returns true when this preview import data bad request response has a 2xx status code
func (o *PreviewImportDataBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this preview import data bad request response has a 3xx status code
func (o *PreviewImportDataBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this preview import data bad request response has a 4xx status code
func (o *PreviewImportDataBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this preview import data bad request response has a 5xx status code
func (o *PreviewImportDataBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this preview import data bad request response a status code equal to that given
func (o *PreviewImportDataBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the preview import data bad request response
func (o *PreviewImportDataBadRequest) Code() int {
	return 400
}

func (o *PreviewImportDataBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataBadRequest %s", 400, payload)
}

func (o *PreviewImportDataBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataBadRequest %s", 400, payload)
}

func (o *PreviewImportDataBadRequest) GetPayload() *PreviewImportDataBadRequestBody {
	return o.Payload
}

func (o *PreviewImportDataBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PreviewImportDataBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPreviewImportDataUnauthorized creates a PreviewImportDataUnauthorized with default headers values
func NewPreviewImportDataUnauthorized() *PreviewImportDataUnauthorized {
	return &PreviewImportDataUnauthorized{}
}

/*
PreviewImportDataUnauthorized describes a response with status code 401, with default header values.

The API key cannot be authenticated.
*/
type PreviewImportDataUnauthorized struct {
	Payload interface{}
}

// IsSuccess returns true when this preview import data unauthorized response has a 2xx status code
func (o *PreviewImportDataUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this preview import data unauthorized response has a 3xx status code
func (o *PreviewImportDataUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this preview import data unauthorized response has a 4xx status code
func (o *PreviewImportDataUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this preview import data unauthorized response has a 5xx status code
func (o *PreviewImportDataUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this preview import data unauthorized response a status code equal to that given
func (o *PreviewImportDataUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the preview import data unauthorized response
func (o *PreviewImportDataUnauthorized) Code() int {
	return 401
}

func (o *PreviewImportDataUnauthorized) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataUnauthorized %s", 401, payload)
}

func (o *PreviewImportDataUnauthorized) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataUnauthorized %s", 401, payload)
}

func (o *PreviewImportDataUnauthorized) GetPayload() interface{} {
	return o.Payload
}

func (o *PreviewImportDataUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPreviewImportDataForbidden creates a PreviewImportDataForbidden with default headers values
func NewPreviewImportDataForbidden() *PreviewImportDataForbidden {
	return &PreviewImportDataForbidden{}
}

/*
PreviewImportDataForbidden describes a response with status code 403, with default header values.

The API key does not have permission to access the resource.
*/
type PreviewImportDataForbidden struct {
	Payload *PreviewImportDataForbiddenBody
}

// IsSuccess returns true when this preview import data forbidden response has a 2xx status code
func (o *PreviewImportDataForbidden) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this preview import data forbidden response has a 3xx status code
func (o *PreviewImportDataForbidden) IsRedirect() bool {
	return false
}

// IsClientError returns true when this preview import data forbidden response has a 4xx status code
func (o *PreviewImportDataForbidden) IsClientError() bool {
	return true
}

// IsServerError returns true when this preview import data forbidden response has a 5xx status code
func (o *PreviewImportDataForbidden) IsServerError() bool {
	return false
}

// IsCode returns true when this preview import data forbidden response a status code equal to that given
func (o *PreviewImportDataForbidden) IsCode(code int) bool {
	return code == 403
}

// Code gets the status code for the preview import data forbidden response
func (o *PreviewImportDataForbidden) Code() int {
	return 403
}

func (o *PreviewImportDataForbidden) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataForbidden %s", 403, payload)
}

func (o *PreviewImportDataForbidden) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataForbidden %s", 403, payload)
}

func (o *PreviewImportDataForbidden) GetPayload() *PreviewImportDataForbiddenBody {
	return o.Payload
}

func (o *PreviewImportDataForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PreviewImportDataForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPreviewImportDataNotFound creates a PreviewImportDataNotFound with default headers values
func NewPreviewImportDataNotFound() *PreviewImportDataNotFound {
	return &PreviewImportDataNotFound{}
}

/*
PreviewImportDataNotFound describes a response with status code 404, with default header values.

The requested resource does not exist.
*/
type PreviewImportDataNotFound struct {
	Payload *PreviewImportDataNotFoundBody
}

// IsSuccess returns true when this preview import data not found response has a 2xx status code
func (o *PreviewImportDataNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this preview import data not found response has a 3xx status code
func (o *PreviewImportDataNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this preview import data not found response has a 4xx status code
func (o *PreviewImportDataNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this preview import data not found response has a 5xx status code
func (o *PreviewImportDataNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this preview import data not found response a status code equal to that given
func (o *PreviewImportDataNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the preview import data not found response
func (o *PreviewImportDataNotFound) Code() int {
	return 404
}

func (o *PreviewImportDataNotFound) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataNotFound %s", 404, payload)
}

func (o *PreviewImportDataNotFound) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataNotFound %s", 404, payload)
}

func (o *PreviewImportDataNotFound) GetPayload() *PreviewImportDataNotFoundBody {
	return o.Payload
}

func (o *PreviewImportDataNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PreviewImportDataNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPreviewImportDataTooManyRequests creates a PreviewImportDataTooManyRequests with default headers values
func NewPreviewImportDataTooManyRequests() *PreviewImportDataTooManyRequests {
	return &PreviewImportDataTooManyRequests{}
}

/*
PreviewImportDataTooManyRequests describes a response with status code 429, with default header values.

You have exceed the rate limit.
*/
type PreviewImportDataTooManyRequests struct {
	Payload *PreviewImportDataTooManyRequestsBody
}

// IsSuccess returns true when this preview import data too many requests response has a 2xx status code
func (o *PreviewImportDataTooManyRequests) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this preview import data too many requests response has a 3xx status code
func (o *PreviewImportDataTooManyRequests) IsRedirect() bool {
	return false
}

// IsClientError returns true when this preview import data too many requests response has a 4xx status code
func (o *PreviewImportDataTooManyRequests) IsClientError() bool {
	return true
}

// IsServerError returns true when this preview import data too many requests response has a 5xx status code
func (o *PreviewImportDataTooManyRequests) IsServerError() bool {
	return false
}

// IsCode returns true when this preview import data too many requests response a status code equal to that given
func (o *PreviewImportDataTooManyRequests) IsCode(code int) bool {
	return code == 429
}

// Code gets the status code for the preview import data too many requests response
func (o *PreviewImportDataTooManyRequests) Code() int {
	return 429
}

func (o *PreviewImportDataTooManyRequests) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataTooManyRequests %s", 429, payload)
}

func (o *PreviewImportDataTooManyRequests) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataTooManyRequests %s", 429, payload)
}

func (o *PreviewImportDataTooManyRequests) GetPayload() *PreviewImportDataTooManyRequestsBody {
	return o.Payload
}

func (o *PreviewImportDataTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PreviewImportDataTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPreviewImportDataInternalServerError creates a PreviewImportDataInternalServerError with default headers values
func NewPreviewImportDataInternalServerError() *PreviewImportDataInternalServerError {
	return &PreviewImportDataInternalServerError{}
}

/*
PreviewImportDataInternalServerError describes a response with status code 500, with default header values.

Server error.
*/
type PreviewImportDataInternalServerError struct {
	Payload *PreviewImportDataInternalServerErrorBody
}

// IsSuccess returns true when this preview import data internal server error response has a 2xx status code
func (o *PreviewImportDataInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this preview import data internal server error response has a 3xx status code
func (o *PreviewImportDataInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this preview import data internal server error response has a 4xx status code
func (o *PreviewImportDataInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this preview import data internal server error response has a 5xx status code
func (o *PreviewImportDataInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this preview import data internal server error response a status code equal to that given
func (o *PreviewImportDataInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the preview import data internal server error response
func (o *PreviewImportDataInternalServerError) Code() int {
	return 500
}

func (o *PreviewImportDataInternalServerError) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataInternalServerError %s", 500, payload)
}

func (o *PreviewImportDataInternalServerError) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] previewImportDataInternalServerError %s", 500, payload)
}

func (o *PreviewImportDataInternalServerError) GetPayload() *PreviewImportDataInternalServerErrorBody {
	return o.Payload
}

func (o *PreviewImportDataInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PreviewImportDataInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPreviewImportDataDefault creates a PreviewImportDataDefault with default headers values
func NewPreviewImportDataDefault(code int) *PreviewImportDataDefault {
	return &PreviewImportDataDefault{
		_statusCode: code,
	}
}

/*
PreviewImportDataDefault describes a response with status code -1, with default header values.

An unexpected error response.
*/
type PreviewImportDataDefault struct {
	_statusCode int

	Payload *PreviewImportDataDefaultBody
}

// IsSuccess returns true when this preview import data default response has a 2xx status code
func (o *PreviewImportDataDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this preview import data default response has a 3xx status code
func (o *PreviewImportDataDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this preview import data default response has a 4xx status code
func (o *PreviewImportDataDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this preview import data default response has a 5xx status code
func (o *PreviewImportDataDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this preview import data default response a status code equal to that given
func (o *PreviewImportDataDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the preview import data default response
func (o *PreviewImportDataDefault) Code() int {
	return o._statusCode
}

func (o *PreviewImportDataDefault) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] PreviewImportData default %s", o._statusCode, payload)
}

func (o *PreviewImportDataDefault) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview][%d] PreviewImportData default %s", o._statusCode, payload)
}

func (o *PreviewImportDataDefault) GetPayload() *PreviewImportDataDefaultBody {
	return o.Payload
}

func (o *PreviewImportDataDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PreviewImportDataDefaultBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
PreviewImportDataBadRequestBody preview import data bad request body
swagger:model PreviewImportDataBadRequestBody
*/
type PreviewImportDataBadRequestBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this preview import data bad request body
func (o *PreviewImportDataBadRequestBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this preview import data bad request body based on context it is used
func (o *PreviewImportDataBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataBadRequestBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataBody PreviewImportDataReq
//
// PreviewImportDataReq is the request to preview the source data before starting an import task for a cluster.
swagger:model PreviewImportDataBody
*/
type PreviewImportDataBody struct {

	// The maximum number of rows to preview for each table.
	// Example: 10
	// Maximum: 20
	// Minimum: 1
	LimitRowsCount *int64 `json:"limit_rows_count,omitempty"`

	// spec
	// Required: true
	Spec *PreviewImportDataParamsBodySpec `json:"spec"`
}

// Validate validates this preview import data body
func (o *PreviewImportDataBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLimitRowsCount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataBody) validateLimitRowsCount(formats strfmt.Registry) error {
	if swag.IsZero(o.LimitRowsCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("body"+"."+"limit_rows_count", "body", *o.LimitRowsCount, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("body"+"."+"limit_rows_count", "body", *o.LimitRowsCount, 20, false); err != nil {
		return err
	}

	return nil
}

func (o *PreviewImportDataBody) validateSpec(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec", "body", o.Spec); err != nil {
		return err
	}

	if o.Spec != nil {
		if err := o.Spec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this preview import data body based on the context it is used
func (o *PreviewImportDataBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataBody) contextValidateSpec(ctx context.Context, formats strfmt.Registry) error {

	if o.Spec != nil {

		if err := o.Spec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataDefaultBody preview import data default body
swagger:model PreviewImportDataDefaultBody
*/
type PreviewImportDataDefaultBody struct {

	// code
	Code int32 `json:"code,omitempty"`

	// details
	Details []*PreviewImportDataDefaultBodyDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`
}

// Validate validates this preview import data default body
func (o *PreviewImportDataDefaultBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataDefaultBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("PreviewImportData default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("PreviewImportData default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this preview import data default body based on the context it is used
func (o *PreviewImportDataDefaultBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataDefaultBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("PreviewImportData default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("PreviewImportData default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataDefaultBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataDefaultBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataDefaultBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataDefaultBodyDetailsItems0 preview import data default body details items0
swagger:model PreviewImportDataDefaultBodyDetailsItems0
*/
type PreviewImportDataDefaultBodyDetailsItems0 struct {

	// at type
	AtType string `json:"@type,omitempty"`

	// preview import data default body details items0
	PreviewImportDataDefaultBodyDetailsItems0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (o *PreviewImportDataDefaultBodyDetailsItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// at type
		AtType string `json:"@type,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv PreviewImportDataDefaultBodyDetailsItems0

	rcv.AtType = stage1.AtType
	*o = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "@type")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		o.PreviewImportDataDefaultBodyDetailsItems0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (o PreviewImportDataDefaultBodyDetailsItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// at type
		AtType string `json:"@type,omitempty"`
	}

	stage1.AtType = o.AtType

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(o.PreviewImportDataDefaultBodyDetailsItems0) == 0 { // no additional properties
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(o.PreviewImportDataDefaultBodyDetailsItems0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 { // "{}": only additional properties
		return additional, nil
	}

	// concatenate the 2 objects
	return swag.ConcatJSON(props, additional), nil
}

// Validate validates this preview import data default body details items0
func (o *PreviewImportDataDefaultBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this preview import data default body details items0 based on context it is used
func (o *PreviewImportDataDefaultBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataDefaultBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataDefaultBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataDefaultBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataForbiddenBody preview import data forbidden body
swagger:model PreviewImportDataForbiddenBody
*/
type PreviewImportDataForbiddenBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this preview import data forbidden body
func (o *PreviewImportDataForbiddenBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this preview import data forbidden body based on context it is used
func (o *PreviewImportDataForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataForbiddenBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataInternalServerErrorBody preview import data internal server error body
swagger:model PreviewImportDataInternalServerErrorBody
*/
type PreviewImportDataInternalServerErrorBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this preview import data internal server error body
func (o *PreviewImportDataInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this preview import data internal server error body based on context it is used
func (o *PreviewImportDataInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataNotFoundBody preview import data not found body
swagger:model PreviewImportDataNotFoundBody
*/
type PreviewImportDataNotFoundBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this preview import data not found body
func (o *PreviewImportDataNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this preview import data not found body based on context it is used
func (o *PreviewImportDataNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataNotFoundBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataOKBody PreviewImportDataResp
//
// PreviewImportDataResp is the response of the source data preview before starting an import task.
swagger:model PreviewImportDataOKBody
*/
type PreviewImportDataOKBody struct {

	// The preview results for each target table from the import task specification.
	TablePreviews []*PreviewImportDataOKBodyTablePreviewsItems0 `json:"table_previews"`
}

// Validate validates this preview import data o k body
func (o *PreviewImportDataOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTablePreviews(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBody) validateTablePreviews(formats strfmt.Registry) error {
	if swag.IsZero(o.TablePreviews) { // not required
		return nil
	}

	for i := 0; i < len(o.TablePreviews); i++ {
		if swag.IsZero(o.TablePreviews[i]) { // not required
			continue
		}

		if o.TablePreviews[i] != nil {
			if err := o.TablePreviews[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("previewImportDataOK" + "." + "table_previews" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("previewImportDataOK" + "." + "table_previews" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this preview import data o k body based on the context it is used
func (o *PreviewImportDataOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTablePreviews(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBody) contextValidateTablePreviews(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TablePreviews); i++ {

		if o.TablePreviews[i] != nil {

			if swag.IsZero(o.TablePreviews[i]) { // not required
				return nil
			}

			if err := o.TablePreviews[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("previewImportDataOK" + "." + "table_previews" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("previewImportDataOK" + "." + "table_previews" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataOKBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataOKBodyTablePreviewsItems0 TablePreview
//
// TablePreview is the preview result for a single table.
swagger:model PreviewImportDataOKBodyTablePreviewsItems0
*/
type PreviewImportDataOKBodyTablePreviewsItems0 struct {

	// data preview
	// Required: true
	DataPreview *PreviewImportDataOKBodyTablePreviewsItems0DataPreview `json:"data_preview"`

	// The database name of the preview table.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// schema preview
	SchemaPreview *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview `json:"schema_preview,omitempty"`

	// The table name of the preview table.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this preview import data o k body table previews items0
func (o *PreviewImportDataOKBodyTablePreviewsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDataPreview(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSchemaPreview(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0) validateDataPreview(formats strfmt.Registry) error {

	if err := validate.Required("data_preview", "body", o.DataPreview); err != nil {
		return err
	}

	if o.DataPreview != nil {
		if err := o.DataPreview.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data_preview")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("data_preview")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0) validateSchemaPreview(formats strfmt.Registry) error {
	if swag.IsZero(o.SchemaPreview) { // not required
		return nil
	}

	if o.SchemaPreview != nil {
		if err := o.SchemaPreview.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema_preview")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema_preview")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this preview import data o k body table previews items0 based on the context it is used
func (o *PreviewImportDataOKBodyTablePreviewsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDataPreview(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSchemaPreview(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0) contextValidateDataPreview(ctx context.Context, formats strfmt.Registry) error {

	if o.DataPreview != nil {

		if err := o.DataPreview.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data_preview")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("data_preview")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0) contextValidateSchemaPreview(ctx context.Context, formats strfmt.Registry) error {

	if o.SchemaPreview != nil {

		if swag.IsZero(o.SchemaPreview) { // not required
			return nil
		}

		if err := o.SchemaPreview.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema_preview")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema_preview")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataOKBodyTablePreviewsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataOKBodyTablePreviewsItems0DataPreview TableData
//
// The data sample for the preview table.
swagger:model PreviewImportDataOKBodyTablePreviewsItems0DataPreview
*/
type PreviewImportDataOKBodyTablePreviewsItems0DataPreview struct {

	// The column names for the following data samples from a table.
	// Example: ["id","column01"]
	ColumnNames []string `json:"column_names"`

	// The rows sampled from a table.
	// Required: true
	Rows []*PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0 `json:"rows"`
}

// Validate validates this preview import data o k body table previews items0 data preview
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreview) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRows(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreview) validateRows(formats strfmt.Registry) error {

	if err := validate.Required("data_preview"+"."+"rows", "body", o.Rows); err != nil {
		return err
	}

	for i := 0; i < len(o.Rows); i++ {
		if swag.IsZero(o.Rows[i]) { // not required
			continue
		}

		if o.Rows[i] != nil {
			if err := o.Rows[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data_preview" + "." + "rows" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("data_preview" + "." + "rows" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this preview import data o k body table previews items0 data preview based on the context it is used
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreview) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRows(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreview) contextValidateRows(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Rows); i++ {

		if o.Rows[i] != nil {

			if swag.IsZero(o.Rows[i]) { // not required
				return nil
			}

			if err := o.Rows[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data_preview" + "." + "rows" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("data_preview" + "." + "rows" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreview) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreview) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataOKBodyTablePreviewsItems0DataPreview
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0 TableDataRow
//
// TableDataRow is a single row in a table.
swagger:model PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0
*/
type PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0 struct {

	// The columns extracted from a table row.
	// Example: ["1","abc"]
	// Required: true
	Columns []string `json:"columns"`
}

// Validate validates this preview import data o k body table previews items0 data preview rows items0
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateColumns(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0) validateColumns(formats strfmt.Registry) error {

	if err := validate.Required("columns", "body", o.Columns); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this preview import data o k body table previews items0 data preview rows items0 based on context it is used
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataOKBodyTablePreviewsItems0DataPreviewRowsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview TableSchema
//
// The schema for the preview table.
swagger:model PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview
*/
type PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview struct {

	// The column definition for each column in the table.
	// Example: [{"column_name":"id","column_type":"INTEGER"},{"column_name":"column01","column_type":"VARCHAR(255)"}]
	// Required: true
	ColumnDefinitions []*PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0 `json:"column_definitions"`

	// The primary key column names for the table. This is optional. The primary key is taken into account when the table is pre-created before an import task is started.
	// Example: ["id"]
	PrimaryKeyColumns []string `json:"primary_key_columns"`
}

// Validate validates this preview import data o k body table previews items0 schema preview
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateColumnDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview) validateColumnDefinitions(formats strfmt.Registry) error {

	if err := validate.Required("schema_preview"+"."+"column_definitions", "body", o.ColumnDefinitions); err != nil {
		return err
	}

	for i := 0; i < len(o.ColumnDefinitions); i++ {
		if swag.IsZero(o.ColumnDefinitions[i]) { // not required
			continue
		}

		if o.ColumnDefinitions[i] != nil {
			if err := o.ColumnDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schema_preview" + "." + "column_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schema_preview" + "." + "column_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this preview import data o k body table previews items0 schema preview based on the context it is used
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateColumnDefinitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview) contextValidateColumnDefinitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ColumnDefinitions); i++ {

		if o.ColumnDefinitions[i] != nil {

			if swag.IsZero(o.ColumnDefinitions[i]) { // not required
				return nil
			}

			if err := o.ColumnDefinitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schema_preview" + "." + "column_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schema_preview" + "." + "column_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataOKBodyTablePreviewsItems0SchemaPreview
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0 ColumnDefinition
//
// ColumnDefinition is the definition of a column in a table.
swagger:model PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0
*/
type PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0 struct {

	// The column name.
	// Example: column01
	// Required: true
	ColumnName *string `json:"column_name"`

	// The column type.
	// Example: VARCHAR(255)
	// Required: true
	ColumnType *string `json:"column_type"`
}

// Validate validates this preview import data o k body table previews items0 schema preview column definitions items0
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateColumnName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateColumnType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0) validateColumnName(formats strfmt.Registry) error {

	if err := validate.Required("column_name", "body", o.ColumnName); err != nil {
		return err
	}

	return nil
}

func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0) validateColumnType(formats strfmt.Registry) error {

	if err := validate.Required("column_type", "body", o.ColumnType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this preview import data o k body table previews items0 schema preview column definitions items0 based on context it is used
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataOKBodyTablePreviewsItems0SchemaPreviewColumnDefinitionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpec ImportSpec
//
// The specifications of the import task.
//
// **Note:** Currently, you can only preview locally uploaded files. This means that only data sources with the `LOCAL_FILE` source type are supported. If you specify a data source other than `LOCAL_FILE`, errors will occur.
swagger:model PreviewImportDataParamsBodySpec
*/
type PreviewImportDataParamsBodySpec struct {

	// source
	// Required: true
	Source *PreviewImportDataParamsBodySpecSource `json:"source"`

	// target
	// Required: true
	Target *PreviewImportDataParamsBodySpecTarget `json:"target"`
}

// Validate validates this preview import data params body spec
func (o *PreviewImportDataParamsBodySpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpec) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source", "body", o.Source); err != nil {
		return err
	}

	if o.Source != nil {
		if err := o.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpec) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"target", "body", o.Target); err != nil {
		return err
	}

	if o.Target != nil {
		if err := o.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this preview import data params body spec based on the context it is used
func (o *PreviewImportDataParamsBodySpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpec) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if o.Source != nil {

		if err := o.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpec) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if o.Target != nil {

		if err := o.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpec) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpec) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecSource ImportSource
//
// The data source settings of the import task.
swagger:model PreviewImportDataParamsBodySpecSource
*/
type PreviewImportDataParamsBodySpecSource struct {

	// aws assume role access
	AwsAssumeRoleAccess *PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess `json:"aws_assume_role_access,omitempty"`

	// aws key access
	AwsKeyAccess *PreviewImportDataParamsBodySpecSourceAwsKeyAccess `json:"aws_key_access,omitempty"`

	// azure token access
	AzureTokenAccess *PreviewImportDataParamsBodySpecSourceAzureTokenAccess `json:"azure_token_access,omitempty"`

	// format
	// Required: true
	Format *PreviewImportDataParamsBodySpecSourceFormat `json:"format"`

	// The data source type of an import task.
	//
	// - `"S3"`: import data from Amazon S3
	// - `"GCS"`: import data from Google Cloud Storage
	// - `"LOCAL_FILE"`: import data from a local file (only available for [TiDB Cloud Serverless](https://docs.pingcap.com/tidbcloud/select-cluster-tier#tidb-cloud-serverless) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
	//
	// **Note:** Currently, if this import spec is used for a [preview](#tag/Import/operation/PreviewImportData) request, only the `LOCAL_FILE` source type is supported.
	// Example: S3
	// Required: true
	// Enum: ["S3","GCS","LOCAL_FILE","AZBLOB"]
	Type *string `json:"type"`

	// The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
	// * `S3`: `s3://`
	// * `GCS`: `gs://`
	// * `LOCAL_FILE`: `file://`.
	//
	// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
	//
	// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
	// Example: s3://example-bucket/example-source-data/
	// Required: true
	URI *string `json:"uri"`
}

// Validate validates this preview import data params body spec source
func (o *PreviewImportDataParamsBodySpecSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAwsAssumeRoleAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAwsKeyAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAzureTokenAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) validateAwsAssumeRoleAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
		return nil
	}

	if o.AwsAssumeRoleAccess != nil {
		if err := o.AwsAssumeRoleAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) validateAwsKeyAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsKeyAccess) { // not required
		return nil
	}

	if o.AwsKeyAccess != nil {
		if err := o.AwsKeyAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) validateAzureTokenAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AzureTokenAccess) { // not required
		return nil
	}

	if o.AzureTokenAccess != nil {
		if err := o.AzureTokenAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"format", "body", o.Format); err != nil {
		return err
	}

	if o.Format != nil {
		if err := o.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

var previewImportDataParamsBodySpecSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","GCS","LOCAL_FILE","AZBLOB"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		previewImportDataParamsBodySpecSourceTypeTypePropEnum = append(previewImportDataParamsBodySpecSourceTypeTypePropEnum, v)
	}
}

const (

	// PreviewImportDataParamsBodySpecSourceTypeS3 captures enum value "S3"
	PreviewImportDataParamsBodySpecSourceTypeS3 string = "S3"

	// PreviewImportDataParamsBodySpecSourceTypeGCS captures enum value "GCS"
	PreviewImportDataParamsBodySpecSourceTypeGCS string = "GCS"

	// PreviewImportDataParamsBodySpecSourceTypeLOCALFILE captures enum value "LOCAL_FILE"
	PreviewImportDataParamsBodySpecSourceTypeLOCALFILE string = "LOCAL_FILE"

	// PreviewImportDataParamsBodySpecSourceTypeAZBLOB captures enum value "AZBLOB"
	PreviewImportDataParamsBodySpecSourceTypeAZBLOB string = "AZBLOB"
)

// prop value enum
func (o *PreviewImportDataParamsBodySpecSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, previewImportDataParamsBodySpecSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) validateType(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("body"+"."+"spec"+"."+"source"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) validateURI(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"uri", "body", o.URI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this preview import data params body spec source based on the context it is used
func (o *PreviewImportDataParamsBodySpecSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAwsAssumeRoleAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAwsKeyAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAzureTokenAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) contextValidateAwsAssumeRoleAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsAssumeRoleAccess != nil {

		if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
			return nil
		}

		if err := o.AwsAssumeRoleAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) contextValidateAwsKeyAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsKeyAccess != nil {

		if swag.IsZero(o.AwsKeyAccess) { // not required
			return nil
		}

		if err := o.AwsKeyAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) contextValidateAzureTokenAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AzureTokenAccess != nil {

		if swag.IsZero(o.AzureTokenAccess) { // not required
			return nil
		}

		if err := o.AzureTokenAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			}
			return err
		}
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSource) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if o.Format != nil {

		if err := o.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSource) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSource) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess AwsAssumeRoleAccess
//
// The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess
*/
type PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess struct {

	// The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
	// Example: arn:aws:iam::999999999999:role/sample-role
	// Required: true
	AssumeRole *string `json:"assume_role"`
}

// Validate validates this preview import data params body spec source aws assume role access
func (o *PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssumeRole(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess) validateAssumeRole(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_assume_role_access"+"."+"assume_role", "body", o.AssumeRole); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this preview import data params body spec source aws assume role access based on context it is used
func (o *PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecSourceAwsAssumeRoleAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecSourceAwsKeyAccess AwsKeyAccess
//
// The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model PreviewImportDataParamsBodySpecSourceAwsKeyAccess
*/
type PreviewImportDataParamsBodySpecSourceAwsKeyAccess struct {

	// The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_ACCESS_KEY_ID
	// Required: true
	AccessKeyID *string `json:"access_key_id"`

	// The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SECRET_ACCESS_KEY
	// Required: true
	SecretAccessKey *string `json:"secret_access_key"`
}

// Validate validates this preview import data params body spec source aws key access
func (o *PreviewImportDataParamsBodySpecSourceAwsKeyAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccessKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecretAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSourceAwsKeyAccess) validateAccessKeyID(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"access_key_id", "body", o.AccessKeyID); err != nil {
		return err
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecSourceAwsKeyAccess) validateSecretAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"secret_access_key", "body", o.SecretAccessKey); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this preview import data params body spec source aws key access based on context it is used
func (o *PreviewImportDataParamsBodySpecSourceAwsKeyAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceAwsKeyAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceAwsKeyAccess) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecSourceAwsKeyAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecSourceAzureTokenAccess AzureTokenAccess
//
// The settings to access the Azblob data with an sas token. This field is only needed if you want to access the Azblob data with an sas token.
swagger:model PreviewImportDataParamsBodySpecSourceAzureTokenAccess
*/
type PreviewImportDataParamsBodySpecSourceAzureTokenAccess struct {

	// The sas token to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SAS_TOKEN
	// Required: true
	SasToken *string `json:"sas_token"`
}

// Validate validates this preview import data params body spec source azure token access
func (o *PreviewImportDataParamsBodySpecSourceAzureTokenAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSasToken(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSourceAzureTokenAccess) validateSasToken(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"azure_token_access"+"."+"sas_token", "body", o.SasToken); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this preview import data params body spec source azure token access based on context it is used
func (o *PreviewImportDataParamsBodySpecSourceAzureTokenAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceAzureTokenAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceAzureTokenAccess) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecSourceAzureTokenAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecSourceFormat ImportSourceFormat
//
// The format settings of the import data source.
swagger:model PreviewImportDataParamsBodySpecSourceFormat
*/
type PreviewImportDataParamsBodySpecSourceFormat struct {

	// csv config
	CsvConfig *PreviewImportDataParamsBodySpecSourceFormatCsvConfig `json:"csv_config,omitempty"`

	// The format type of an import source.
	// Example: CSV
	// Required: true
	// Enum: ["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]
	Type *string `json:"type"`
}

// Validate validates this preview import data params body spec source format
func (o *PreviewImportDataParamsBodySpecSourceFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCsvConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSourceFormat) validateCsvConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.CsvConfig) { // not required
		return nil
	}

	if o.CsvConfig != nil {
		if err := o.CsvConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

var previewImportDataParamsBodySpecSourceFormatTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		previewImportDataParamsBodySpecSourceFormatTypeTypePropEnum = append(previewImportDataParamsBodySpecSourceFormatTypeTypePropEnum, v)
	}
}

const (

	// PreviewImportDataParamsBodySpecSourceFormatTypeCSV captures enum value "CSV"
	PreviewImportDataParamsBodySpecSourceFormatTypeCSV string = "CSV"

	// PreviewImportDataParamsBodySpecSourceFormatTypePARQUET captures enum value "PARQUET"
	PreviewImportDataParamsBodySpecSourceFormatTypePARQUET string = "PARQUET"

	// PreviewImportDataParamsBodySpecSourceFormatTypeSQL captures enum value "SQL"
	PreviewImportDataParamsBodySpecSourceFormatTypeSQL string = "SQL"

	// PreviewImportDataParamsBodySpecSourceFormatTypeAURORASNAPSHOT captures enum value "AURORA_SNAPSHOT"
	PreviewImportDataParamsBodySpecSourceFormatTypeAURORASNAPSHOT string = "AURORA_SNAPSHOT"
)

// prop value enum
func (o *PreviewImportDataParamsBodySpecSourceFormat) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, previewImportDataParamsBodySpecSourceFormatTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSourceFormat) validateType(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("body"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this preview import data params body spec source format based on the context it is used
func (o *PreviewImportDataParamsBodySpecSourceFormat) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCsvConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecSourceFormat) contextValidateCsvConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.CsvConfig != nil {

		if swag.IsZero(o.CsvConfig) { // not required
			return nil
		}

		if err := o.CsvConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("body" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceFormat) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceFormat) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecSourceFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecSourceFormatCsvConfig ImportSourceCSVConfig
//
// The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
swagger:model PreviewImportDataParamsBodySpecSourceFormatCsvConfig
*/
type PreviewImportDataParamsBodySpecSourceFormatCsvConfig struct {

	// Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
	//
	// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
	BackslashEscape *bool `json:"backslash_escape,omitempty"`

	// The delimiter character used to separate fields in the CSV data.
	Delimiter *string `json:"delimiter,omitempty"`

	// Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
	HasHeaderRow *bool `json:"has_header_row,omitempty"`

	// The character used to quote the fields in the CSV data.
	Quote *string `json:"quote,omitempty"`
}

// Validate validates this preview import data params body spec source format csv config
func (o *PreviewImportDataParamsBodySpecSourceFormatCsvConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this preview import data params body spec source format csv config based on context it is used
func (o *PreviewImportDataParamsBodySpecSourceFormatCsvConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceFormatCsvConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecSourceFormatCsvConfig) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecSourceFormatCsvConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecTarget ImportTarget
//
// The target settings of the import task.
swagger:model PreviewImportDataParamsBodySpecTarget
*/
type PreviewImportDataParamsBodySpecTarget struct {

	// The settings for each target table that is being imported for the import task. If you leave it empty, the system will scan all the files in the data source using the default file patterns and collect all the tables to import. The files include data files, table schema files, and DB schema files. If you provide a list of tables, only those tables will be imported. For more information about the default file pattern, see [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Limitations:**
	// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
	// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
	// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
	Tables []*PreviewImportDataParamsBodySpecTargetTablesItems0 `json:"tables"`
}

// Validate validates this preview import data params body spec target
func (o *PreviewImportDataParamsBodySpecTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecTarget) validateTables(formats strfmt.Registry) error {
	if swag.IsZero(o.Tables) { // not required
		return nil
	}

	for i := 0; i < len(o.Tables); i++ {
		if swag.IsZero(o.Tables[i]) { // not required
			continue
		}

		if o.Tables[i] != nil {
			if err := o.Tables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this preview import data params body spec target based on the context it is used
func (o *PreviewImportDataParamsBodySpecTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecTarget) contextValidateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Tables); i++ {

		if o.Tables[i] != nil {

			if swag.IsZero(o.Tables[i]) { // not required
				return nil
			}

			if err := o.Tables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecTarget) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecTarget) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataParamsBodySpecTargetTablesItems0 ImportTargetTable
//
// ImportTargetTable represents the settings for importing source data into a single target table of an import task.
swagger:model PreviewImportDataParamsBodySpecTargetTablesItems0
*/
type PreviewImportDataParamsBodySpecTargetTablesItems0 struct {

	// The target database name.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
	// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
	// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
	//
	// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
	//
	// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
	//
	// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
	// Example: data/db01/table01.*.csv
	FileNamePattern string `json:"file_name_pattern,omitempty"`

	// The target table name.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this preview import data params body spec target tables items0
func (o *PreviewImportDataParamsBodySpecTargetTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PreviewImportDataParamsBodySpecTargetTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *PreviewImportDataParamsBodySpecTargetTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this preview import data params body spec target tables items0 based on context it is used
func (o *PreviewImportDataParamsBodySpecTargetTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecTargetTablesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataParamsBodySpecTargetTablesItems0) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataParamsBodySpecTargetTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PreviewImportDataTooManyRequestsBody preview import data too many requests body
swagger:model PreviewImportDataTooManyRequestsBody
*/
type PreviewImportDataTooManyRequestsBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this preview import data too many requests body
func (o *PreviewImportDataTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this preview import data too many requests body based on context it is used
func (o *PreviewImportDataTooManyRequestsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PreviewImportDataTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PreviewImportDataTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res PreviewImportDataTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
