// Code generated by go-swagger; DO NOT EDIT.

package import_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ListImportTasksReader is a Reader for the ListImportTasks structure.
type ListImportTasksReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *ListImportTasksReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewListImportTasksOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewListImportTasksBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewListImportTasksUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewListImportTasksForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewListImportTasksNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewListImportTasksTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewListImportTasksInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewListImportTasksDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewListImportTasksOK creates a ListImportTasksOK with default headers values
func NewListImportTasksOK() *ListImportTasksOK {
	return &ListImportTasksOK{}
}

/*
ListImportTasksOK describes a response with status code 200, with default header values.

A successful response.
*/
type ListImportTasksOK struct {
	Payload *ListImportTasksOKBody
}

// IsSuccess returns true when this list import tasks o k response has a 2xx status code
func (o *ListImportTasksOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this list import tasks o k response has a 3xx status code
func (o *ListImportTasksOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this list import tasks o k response has a 4xx status code
func (o *ListImportTasksOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this list import tasks o k response has a 5xx status code
func (o *ListImportTasksOK) IsServerError() bool {
	return false
}

// IsCode returns true when this list import tasks o k response a status code equal to that given
func (o *ListImportTasksOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the list import tasks o k response
func (o *ListImportTasksOK) Code() int {
	return 200
}

func (o *ListImportTasksOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksOK %s", 200, payload)
}

func (o *ListImportTasksOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksOK %s", 200, payload)
}

func (o *ListImportTasksOK) GetPayload() *ListImportTasksOKBody {
	return o.Payload
}

func (o *ListImportTasksOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ListImportTasksOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewListImportTasksBadRequest creates a ListImportTasksBadRequest with default headers values
func NewListImportTasksBadRequest() *ListImportTasksBadRequest {
	return &ListImportTasksBadRequest{}
}

/*
ListImportTasksBadRequest describes a response with status code 400, with default header values.

A request field is invalid.
*/
type ListImportTasksBadRequest struct {
	Payload *ListImportTasksBadRequestBody
}

// IsSuccess returns true when this list import tasks bad request response has a 2xx status code
func (o *ListImportTasksBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this list import tasks bad request response has a 3xx status code
func (o *ListImportTasksBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this list import tasks bad request response has a 4xx status code
func (o *ListImportTasksBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this list import tasks bad request response has a 5xx status code
func (o *ListImportTasksBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this list import tasks bad request response a status code equal to that given
func (o *ListImportTasksBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the list import tasks bad request response
func (o *ListImportTasksBadRequest) Code() int {
	return 400
}

func (o *ListImportTasksBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksBadRequest %s", 400, payload)
}

func (o *ListImportTasksBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksBadRequest %s", 400, payload)
}

func (o *ListImportTasksBadRequest) GetPayload() *ListImportTasksBadRequestBody {
	return o.Payload
}

func (o *ListImportTasksBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ListImportTasksBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewListImportTasksUnauthorized creates a ListImportTasksUnauthorized with default headers values
func NewListImportTasksUnauthorized() *ListImportTasksUnauthorized {
	return &ListImportTasksUnauthorized{}
}

/*
ListImportTasksUnauthorized describes a response with status code 401, with default header values.

The API key cannot be authenticated.
*/
type ListImportTasksUnauthorized struct {
	Payload interface{}
}

// IsSuccess returns true when this list import tasks unauthorized response has a 2xx status code
func (o *ListImportTasksUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this list import tasks unauthorized response has a 3xx status code
func (o *ListImportTasksUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this list import tasks unauthorized response has a 4xx status code
func (o *ListImportTasksUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this list import tasks unauthorized response has a 5xx status code
func (o *ListImportTasksUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this list import tasks unauthorized response a status code equal to that given
func (o *ListImportTasksUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the list import tasks unauthorized response
func (o *ListImportTasksUnauthorized) Code() int {
	return 401
}

func (o *ListImportTasksUnauthorized) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksUnauthorized %s", 401, payload)
}

func (o *ListImportTasksUnauthorized) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksUnauthorized %s", 401, payload)
}

func (o *ListImportTasksUnauthorized) GetPayload() interface{} {
	return o.Payload
}

func (o *ListImportTasksUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewListImportTasksForbidden creates a ListImportTasksForbidden with default headers values
func NewListImportTasksForbidden() *ListImportTasksForbidden {
	return &ListImportTasksForbidden{}
}

/*
ListImportTasksForbidden describes a response with status code 403, with default header values.

The API key does not have permission to access the resource.
*/
type ListImportTasksForbidden struct {
	Payload *ListImportTasksForbiddenBody
}

// IsSuccess returns true when this list import tasks forbidden response has a 2xx status code
func (o *ListImportTasksForbidden) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this list import tasks forbidden response has a 3xx status code
func (o *ListImportTasksForbidden) IsRedirect() bool {
	return false
}

// IsClientError returns true when this list import tasks forbidden response has a 4xx status code
func (o *ListImportTasksForbidden) IsClientError() bool {
	return true
}

// IsServerError returns true when this list import tasks forbidden response has a 5xx status code
func (o *ListImportTasksForbidden) IsServerError() bool {
	return false
}

// IsCode returns true when this list import tasks forbidden response a status code equal to that given
func (o *ListImportTasksForbidden) IsCode(code int) bool {
	return code == 403
}

// Code gets the status code for the list import tasks forbidden response
func (o *ListImportTasksForbidden) Code() int {
	return 403
}

func (o *ListImportTasksForbidden) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksForbidden %s", 403, payload)
}

func (o *ListImportTasksForbidden) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksForbidden %s", 403, payload)
}

func (o *ListImportTasksForbidden) GetPayload() *ListImportTasksForbiddenBody {
	return o.Payload
}

func (o *ListImportTasksForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ListImportTasksForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewListImportTasksNotFound creates a ListImportTasksNotFound with default headers values
func NewListImportTasksNotFound() *ListImportTasksNotFound {
	return &ListImportTasksNotFound{}
}

/*
ListImportTasksNotFound describes a response with status code 404, with default header values.

The requested resource does not exist.
*/
type ListImportTasksNotFound struct {
	Payload *ListImportTasksNotFoundBody
}

// IsSuccess returns true when this list import tasks not found response has a 2xx status code
func (o *ListImportTasksNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this list import tasks not found response has a 3xx status code
func (o *ListImportTasksNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this list import tasks not found response has a 4xx status code
func (o *ListImportTasksNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this list import tasks not found response has a 5xx status code
func (o *ListImportTasksNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this list import tasks not found response a status code equal to that given
func (o *ListImportTasksNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the list import tasks not found response
func (o *ListImportTasksNotFound) Code() int {
	return 404
}

func (o *ListImportTasksNotFound) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksNotFound %s", 404, payload)
}

func (o *ListImportTasksNotFound) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksNotFound %s", 404, payload)
}

func (o *ListImportTasksNotFound) GetPayload() *ListImportTasksNotFoundBody {
	return o.Payload
}

func (o *ListImportTasksNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ListImportTasksNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewListImportTasksTooManyRequests creates a ListImportTasksTooManyRequests with default headers values
func NewListImportTasksTooManyRequests() *ListImportTasksTooManyRequests {
	return &ListImportTasksTooManyRequests{}
}

/*
ListImportTasksTooManyRequests describes a response with status code 429, with default header values.

You have exceed the rate limit.
*/
type ListImportTasksTooManyRequests struct {
	Payload *ListImportTasksTooManyRequestsBody
}

// IsSuccess returns true when this list import tasks too many requests response has a 2xx status code
func (o *ListImportTasksTooManyRequests) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this list import tasks too many requests response has a 3xx status code
func (o *ListImportTasksTooManyRequests) IsRedirect() bool {
	return false
}

// IsClientError returns true when this list import tasks too many requests response has a 4xx status code
func (o *ListImportTasksTooManyRequests) IsClientError() bool {
	return true
}

// IsServerError returns true when this list import tasks too many requests response has a 5xx status code
func (o *ListImportTasksTooManyRequests) IsServerError() bool {
	return false
}

// IsCode returns true when this list import tasks too many requests response a status code equal to that given
func (o *ListImportTasksTooManyRequests) IsCode(code int) bool {
	return code == 429
}

// Code gets the status code for the list import tasks too many requests response
func (o *ListImportTasksTooManyRequests) Code() int {
	return 429
}

func (o *ListImportTasksTooManyRequests) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksTooManyRequests %s", 429, payload)
}

func (o *ListImportTasksTooManyRequests) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksTooManyRequests %s", 429, payload)
}

func (o *ListImportTasksTooManyRequests) GetPayload() *ListImportTasksTooManyRequestsBody {
	return o.Payload
}

func (o *ListImportTasksTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ListImportTasksTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewListImportTasksInternalServerError creates a ListImportTasksInternalServerError with default headers values
func NewListImportTasksInternalServerError() *ListImportTasksInternalServerError {
	return &ListImportTasksInternalServerError{}
}

/*
ListImportTasksInternalServerError describes a response with status code 500, with default header values.

Server error.
*/
type ListImportTasksInternalServerError struct {
	Payload *ListImportTasksInternalServerErrorBody
}

// IsSuccess returns true when this list import tasks internal server error response has a 2xx status code
func (o *ListImportTasksInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this list import tasks internal server error response has a 3xx status code
func (o *ListImportTasksInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this list import tasks internal server error response has a 4xx status code
func (o *ListImportTasksInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this list import tasks internal server error response has a 5xx status code
func (o *ListImportTasksInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this list import tasks internal server error response a status code equal to that given
func (o *ListImportTasksInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the list import tasks internal server error response
func (o *ListImportTasksInternalServerError) Code() int {
	return 500
}

func (o *ListImportTasksInternalServerError) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksInternalServerError %s", 500, payload)
}

func (o *ListImportTasksInternalServerError) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] listImportTasksInternalServerError %s", 500, payload)
}

func (o *ListImportTasksInternalServerError) GetPayload() *ListImportTasksInternalServerErrorBody {
	return o.Payload
}

func (o *ListImportTasksInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ListImportTasksInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewListImportTasksDefault creates a ListImportTasksDefault with default headers values
func NewListImportTasksDefault(code int) *ListImportTasksDefault {
	return &ListImportTasksDefault{
		_statusCode: code,
	}
}

/*
ListImportTasksDefault describes a response with status code -1, with default header values.

An unexpected error response.
*/
type ListImportTasksDefault struct {
	_statusCode int

	Payload *ListImportTasksDefaultBody
}

// IsSuccess returns true when this list import tasks default response has a 2xx status code
func (o *ListImportTasksDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this list import tasks default response has a 3xx status code
func (o *ListImportTasksDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this list import tasks default response has a 4xx status code
func (o *ListImportTasksDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this list import tasks default response has a 5xx status code
func (o *ListImportTasksDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this list import tasks default response a status code equal to that given
func (o *ListImportTasksDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the list import tasks default response
func (o *ListImportTasksDefault) Code() int {
	return o._statusCode
}

func (o *ListImportTasksDefault) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] ListImportTasks default %s", o._statusCode, payload)
}

func (o *ListImportTasksDefault) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports][%d] ListImportTasks default %s", o._statusCode, payload)
}

func (o *ListImportTasksDefault) GetPayload() *ListImportTasksDefaultBody {
	return o.Payload
}

func (o *ListImportTasksDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ListImportTasksDefaultBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
ListImportTasksBadRequestBody list import tasks bad request body
swagger:model ListImportTasksBadRequestBody
*/
type ListImportTasksBadRequestBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this list import tasks bad request body
func (o *ListImportTasksBadRequestBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this list import tasks bad request body based on context it is used
func (o *ListImportTasksBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksBadRequestBody) UnmarshalBinary(b []byte) error {
	var res ListImportTasksBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksDefaultBody list import tasks default body
swagger:model ListImportTasksDefaultBody
*/
type ListImportTasksDefaultBody struct {

	// code
	Code int32 `json:"code,omitempty"`

	// details
	Details []*ListImportTasksDefaultBodyDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`
}

// Validate validates this list import tasks default body
func (o *ListImportTasksDefaultBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksDefaultBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ListImportTasks default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ListImportTasks default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this list import tasks default body based on the context it is used
func (o *ListImportTasksDefaultBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksDefaultBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ListImportTasks default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ListImportTasks default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksDefaultBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksDefaultBody) UnmarshalBinary(b []byte) error {
	var res ListImportTasksDefaultBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksDefaultBodyDetailsItems0 list import tasks default body details items0
swagger:model ListImportTasksDefaultBodyDetailsItems0
*/
type ListImportTasksDefaultBodyDetailsItems0 struct {

	// at type
	AtType string `json:"@type,omitempty"`

	// list import tasks default body details items0
	ListImportTasksDefaultBodyDetailsItems0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (o *ListImportTasksDefaultBodyDetailsItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// at type
		AtType string `json:"@type,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv ListImportTasksDefaultBodyDetailsItems0

	rcv.AtType = stage1.AtType
	*o = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "@type")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		o.ListImportTasksDefaultBodyDetailsItems0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (o ListImportTasksDefaultBodyDetailsItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// at type
		AtType string `json:"@type,omitempty"`
	}

	stage1.AtType = o.AtType

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(o.ListImportTasksDefaultBodyDetailsItems0) == 0 { // no additional properties
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(o.ListImportTasksDefaultBodyDetailsItems0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 { // "{}": only additional properties
		return additional, nil
	}

	// concatenate the 2 objects
	return swag.ConcatJSON(props, additional), nil
}

// Validate validates this list import tasks default body details items0
func (o *ListImportTasksDefaultBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this list import tasks default body details items0 based on context it is used
func (o *ListImportTasksDefaultBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksDefaultBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksDefaultBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res ListImportTasksDefaultBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksForbiddenBody list import tasks forbidden body
swagger:model ListImportTasksForbiddenBody
*/
type ListImportTasksForbiddenBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this list import tasks forbidden body
func (o *ListImportTasksForbiddenBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this list import tasks forbidden body based on context it is used
func (o *ListImportTasksForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksForbiddenBody) UnmarshalBinary(b []byte) error {
	var res ListImportTasksForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksInternalServerErrorBody list import tasks internal server error body
swagger:model ListImportTasksInternalServerErrorBody
*/
type ListImportTasksInternalServerErrorBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this list import tasks internal server error body
func (o *ListImportTasksInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this list import tasks internal server error body based on context it is used
func (o *ListImportTasksInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res ListImportTasksInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksNotFoundBody list import tasks not found body
swagger:model ListImportTasksNotFoundBody
*/
type ListImportTasksNotFoundBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this list import tasks not found body
func (o *ListImportTasksNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this list import tasks not found body based on context it is used
func (o *ListImportTasksNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksNotFoundBody) UnmarshalBinary(b []byte) error {
	var res ListImportTasksNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBody ListImportTasksResp
//
// ListImportTasksResp is the response for listing the import tasks of a cluster.
swagger:model ListImportTasksOKBody
*/
type ListImportTasksOKBody struct {

	// The import tasks in the cluster in the request page area.
	// Required: true
	Items []*ListImportTasksOKBodyItemsItems0 `json:"items"`

	// The total number of import tasks in the cluster.
	// Example: 20
	// Required: true
	Total *int64 `json:"total"`
}

// Validate validates this list import tasks o k body
func (o *ListImportTasksOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotal(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBody) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("listImportTasksOK"+"."+"items", "body", o.Items); err != nil {
		return err
	}

	for i := 0; i < len(o.Items); i++ {
		if swag.IsZero(o.Items[i]) { // not required
			continue
		}

		if o.Items[i] != nil {
			if err := o.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("listImportTasksOK" + "." + "items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("listImportTasksOK" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *ListImportTasksOKBody) validateTotal(formats strfmt.Registry) error {

	if err := validate.Required("listImportTasksOK"+"."+"total", "body", o.Total); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this list import tasks o k body based on the context it is used
func (o *ListImportTasksOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBody) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Items); i++ {

		if o.Items[i] != nil {

			if swag.IsZero(o.Items[i]) { // not required
				return nil
			}

			if err := o.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("listImportTasksOK" + "." + "items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("listImportTasksOK" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBody) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0 ImportItem
//
// ImportItem represents the information of a single import task.
swagger:model ListImportTasksOKBodyItemsItems0
*/
type ListImportTasksOKBodyItemsItems0 struct {

	// metadata
	Metadata *ListImportTasksOKBodyItemsItems0Metadata `json:"metadata,omitempty"`

	// spec
	Spec *ListImportTasksOKBodyItemsItems0Spec `json:"spec,omitempty"`

	// status
	Status *ListImportTasksOKBodyItemsItems0Status `json:"status,omitempty"`
}

// Validate validates this list import tasks o k body items items0
func (o *ListImportTasksOKBodyItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0) validateSpec(formats strfmt.Registry) error {
	if swag.IsZero(o.Spec) { // not required
		return nil
	}

	if o.Spec != nil {
		if err := o.Spec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.Status) { // not required
		return nil
	}

	if o.Status != nil {
		if err := o.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this list import tasks o k body items items0 based on the context it is used
func (o *ListImportTasksOKBodyItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {

		if swag.IsZero(o.Metadata) { // not required
			return nil
		}

		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0) contextValidateSpec(ctx context.Context, formats strfmt.Registry) error {

	if o.Spec != nil {

		if swag.IsZero(o.Spec) { // not required
			return nil
		}

		if err := o.Spec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if o.Status != nil {

		if swag.IsZero(o.Status) { // not required
			return nil
		}

		if err := o.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0Metadata ImportMetadata
//
// The metadata of the import task.
swagger:model ListImportTasksOKBodyItemsItems0Metadata
*/
type ListImportTasksOKBodyItemsItems0Metadata struct {

	// The creation time of the import task in Unix timestamp seconds (epoch time).
	// Example: 1676450597
	// Required: true
	CreateTimestamp *string `json:"create_timestamp"`

	// The ID of the import task.
	// Example: 1
	// Required: true
	ID *string `json:"id"`

	// The name of the import task.
	// Example: my_import
	Name string `json:"name,omitempty"`
}

// Validate validates this list import tasks o k body items items0 metadata
func (o *ListImportTasksOKBodyItemsItems0Metadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCreateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Metadata) validateCreateTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("metadata"+"."+"create_timestamp", "body", o.CreateTimestamp); err != nil {
		return err
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Metadata) validateID(formats strfmt.Registry) error {

	if err := validate.Required("metadata"+"."+"id", "body", o.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this list import tasks o k body items items0 metadata based on context it is used
func (o *ListImportTasksOKBodyItemsItems0Metadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0Metadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0Metadata) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0Metadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0Spec ImportSpec
//
// The specification of the import task.
swagger:model ListImportTasksOKBodyItemsItems0Spec
*/
type ListImportTasksOKBodyItemsItems0Spec struct {

	// source
	// Required: true
	Source *ListImportTasksOKBodyItemsItems0SpecSource `json:"source"`

	// target
	// Required: true
	Target *ListImportTasksOKBodyItemsItems0SpecTarget `json:"target"`
}

// Validate validates this list import tasks o k body items items0 spec
func (o *ListImportTasksOKBodyItemsItems0Spec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Spec) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source", "body", o.Source); err != nil {
		return err
	}

	if o.Source != nil {
		if err := o.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Spec) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"target", "body", o.Target); err != nil {
		return err
	}

	if o.Target != nil {
		if err := o.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this list import tasks o k body items items0 spec based on the context it is used
func (o *ListImportTasksOKBodyItemsItems0Spec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Spec) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if o.Source != nil {

		if err := o.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Spec) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if o.Target != nil {

		if err := o.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0Spec) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0Spec) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0Spec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecSource ImportSource
//
// The data source settings of the import task.
swagger:model ListImportTasksOKBodyItemsItems0SpecSource
*/
type ListImportTasksOKBodyItemsItems0SpecSource struct {

	// aws assume role access
	AwsAssumeRoleAccess *ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess `json:"aws_assume_role_access,omitempty"`

	// aws key access
	AwsKeyAccess *ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess `json:"aws_key_access,omitempty"`

	// azure token access
	AzureTokenAccess *ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess `json:"azure_token_access,omitempty"`

	// format
	// Required: true
	Format *ListImportTasksOKBodyItemsItems0SpecSourceFormat `json:"format"`

	// The data source type of an import task.
	//
	// - `"S3"`: import data from Amazon S3
	// - `"GCS"`: import data from Google Cloud Storage
	// - `"LOCAL_FILE"`: import data from a local file (only available for [TiDB Cloud Serverless](https://docs.pingcap.com/tidbcloud/select-cluster-tier#tidb-cloud-serverless) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
	//
	// **Note:** Currently, if this import spec is used for a [preview](#tag/Import/operation/PreviewImportData) request, only the `LOCAL_FILE` source type is supported.
	// Example: S3
	// Required: true
	// Enum: ["S3","GCS","LOCAL_FILE","AZBLOB"]
	Type *string `json:"type"`

	// The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
	// * `S3`: `s3://`
	// * `GCS`: `gs://`
	// * `LOCAL_FILE`: `file://`.
	//
	// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
	//
	// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
	// Example: s3://example-bucket/example-source-data/
	// Required: true
	URI *string `json:"uri"`
}

// Validate validates this list import tasks o k body items items0 spec source
func (o *ListImportTasksOKBodyItemsItems0SpecSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAwsAssumeRoleAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAwsKeyAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAzureTokenAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) validateAwsAssumeRoleAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
		return nil
	}

	if o.AwsAssumeRoleAccess != nil {
		if err := o.AwsAssumeRoleAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) validateAwsKeyAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsKeyAccess) { // not required
		return nil
	}

	if o.AwsKeyAccess != nil {
		if err := o.AwsKeyAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) validateAzureTokenAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AzureTokenAccess) { // not required
		return nil
	}

	if o.AzureTokenAccess != nil {
		if err := o.AzureTokenAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "azure_token_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "azure_token_access")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"format", "body", o.Format); err != nil {
		return err
	}

	if o.Format != nil {
		if err := o.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

var listImportTasksOKBodyItemsItems0SpecSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","GCS","LOCAL_FILE","AZBLOB"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		listImportTasksOKBodyItemsItems0SpecSourceTypeTypePropEnum = append(listImportTasksOKBodyItemsItems0SpecSourceTypeTypePropEnum, v)
	}
}

const (

	// ListImportTasksOKBodyItemsItems0SpecSourceTypeS3 captures enum value "S3"
	ListImportTasksOKBodyItemsItems0SpecSourceTypeS3 string = "S3"

	// ListImportTasksOKBodyItemsItems0SpecSourceTypeGCS captures enum value "GCS"
	ListImportTasksOKBodyItemsItems0SpecSourceTypeGCS string = "GCS"

	// ListImportTasksOKBodyItemsItems0SpecSourceTypeLOCALFILE captures enum value "LOCAL_FILE"
	ListImportTasksOKBodyItemsItems0SpecSourceTypeLOCALFILE string = "LOCAL_FILE"

	// ListImportTasksOKBodyItemsItems0SpecSourceTypeAZBLOB captures enum value "AZBLOB"
	ListImportTasksOKBodyItemsItems0SpecSourceTypeAZBLOB string = "AZBLOB"
)

// prop value enum
func (o *ListImportTasksOKBodyItemsItems0SpecSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, listImportTasksOKBodyItemsItems0SpecSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) validateType(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("spec"+"."+"source"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) validateURI(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"uri", "body", o.URI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this list import tasks o k body items items0 spec source based on the context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAwsAssumeRoleAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAwsKeyAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAzureTokenAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) contextValidateAwsAssumeRoleAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsAssumeRoleAccess != nil {

		if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
			return nil
		}

		if err := o.AwsAssumeRoleAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) contextValidateAwsKeyAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsKeyAccess != nil {

		if swag.IsZero(o.AwsKeyAccess) { // not required
			return nil
		}

		if err := o.AwsKeyAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) contextValidateAzureTokenAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AzureTokenAccess != nil {

		if swag.IsZero(o.AzureTokenAccess) { // not required
			return nil
		}

		if err := o.AzureTokenAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "azure_token_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "azure_token_access")
			}
			return err
		}
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSource) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if o.Format != nil {

		if err := o.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSource) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSource) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess AwsAssumeRoleAccess
//
// The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess
*/
type ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess struct {

	// The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
	// Example: arn:aws:iam::999999999999:role/sample-role
	// Required: true
	AssumeRole *string `json:"assume_role"`
}

// Validate validates this list import tasks o k body items items0 spec source aws assume role access
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssumeRole(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess) validateAssumeRole(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_assume_role_access"+"."+"assume_role", "body", o.AssumeRole); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this list import tasks o k body items items0 spec source aws assume role access based on context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecSourceAwsAssumeRoleAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess AwsKeyAccess
//
// The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess
*/
type ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess struct {

	// The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_ACCESS_KEY_ID
	// Required: true
	AccessKeyID *string `json:"access_key_id"`

	// The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SECRET_ACCESS_KEY
	// Required: true
	SecretAccessKey *string `json:"secret_access_key"`
}

// Validate validates this list import tasks o k body items items0 spec source aws key access
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccessKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecretAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess) validateAccessKeyID(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_key_access"+"."+"access_key_id", "body", o.AccessKeyID); err != nil {
		return err
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess) validateSecretAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_key_access"+"."+"secret_access_key", "body", o.SecretAccessKey); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this list import tasks o k body items items0 spec source aws key access based on context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecSourceAwsKeyAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess AzureTokenAccess
//
// The settings to access the Azblob data with an sas token. This field is only needed if you want to access the Azblob data with an sas token.
swagger:model ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess
*/
type ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess struct {

	// The sas token to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SAS_TOKEN
	// Required: true
	SasToken *string `json:"sas_token"`
}

// Validate validates this list import tasks o k body items items0 spec source azure token access
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSasToken(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess) validateSasToken(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"azure_token_access"+"."+"sas_token", "body", o.SasToken); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this list import tasks o k body items items0 spec source azure token access based on context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecSourceAzureTokenAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecSourceFormat ImportSourceFormat
//
// The format settings of the import data source.
swagger:model ListImportTasksOKBodyItemsItems0SpecSourceFormat
*/
type ListImportTasksOKBodyItemsItems0SpecSourceFormat struct {

	// csv config
	CsvConfig *ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig `json:"csv_config,omitempty"`

	// The format type of an import source.
	// Example: CSV
	// Required: true
	// Enum: ["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]
	Type *string `json:"type"`
}

// Validate validates this list import tasks o k body items items0 spec source format
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCsvConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) validateCsvConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.CsvConfig) { // not required
		return nil
	}

	if o.CsvConfig != nil {
		if err := o.CsvConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

var listImportTasksOKBodyItemsItems0SpecSourceFormatTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		listImportTasksOKBodyItemsItems0SpecSourceFormatTypeTypePropEnum = append(listImportTasksOKBodyItemsItems0SpecSourceFormatTypeTypePropEnum, v)
	}
}

const (

	// ListImportTasksOKBodyItemsItems0SpecSourceFormatTypeCSV captures enum value "CSV"
	ListImportTasksOKBodyItemsItems0SpecSourceFormatTypeCSV string = "CSV"

	// ListImportTasksOKBodyItemsItems0SpecSourceFormatTypePARQUET captures enum value "PARQUET"
	ListImportTasksOKBodyItemsItems0SpecSourceFormatTypePARQUET string = "PARQUET"

	// ListImportTasksOKBodyItemsItems0SpecSourceFormatTypeSQL captures enum value "SQL"
	ListImportTasksOKBodyItemsItems0SpecSourceFormatTypeSQL string = "SQL"

	// ListImportTasksOKBodyItemsItems0SpecSourceFormatTypeAURORASNAPSHOT captures enum value "AURORA_SNAPSHOT"
	ListImportTasksOKBodyItemsItems0SpecSourceFormatTypeAURORASNAPSHOT string = "AURORA_SNAPSHOT"
)

// prop value enum
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, listImportTasksOKBodyItemsItems0SpecSourceFormatTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) validateType(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"format"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("spec"+"."+"source"+"."+"format"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this list import tasks o k body items items0 spec source format based on the context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCsvConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) contextValidateCsvConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.CsvConfig != nil {

		if swag.IsZero(o.CsvConfig) { // not required
			return nil
		}

		if err := o.CsvConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormat) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecSourceFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig ImportSourceCSVConfig
//
// The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
swagger:model ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig
*/
type ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig struct {

	// Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
	//
	// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
	BackslashEscape *bool `json:"backslash_escape,omitempty"`

	// The delimiter character used to separate fields in the CSV data.
	Delimiter *string `json:"delimiter,omitempty"`

	// Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
	HasHeaderRow *bool `json:"has_header_row,omitempty"`

	// The character used to quote the fields in the CSV data.
	Quote *string `json:"quote,omitempty"`
}

// Validate validates this list import tasks o k body items items0 spec source format csv config
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this list import tasks o k body items items0 spec source format csv config based on context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecSourceFormatCsvConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecTarget ImportTarget
//
// The target settings of the import task.
swagger:model ListImportTasksOKBodyItemsItems0SpecTarget
*/
type ListImportTasksOKBodyItemsItems0SpecTarget struct {

	// The settings for each target table that is being imported for the import task. If you leave it empty, the system will scan all the files in the data source using the default file patterns and collect all the tables to import. The files include data files, table schema files, and DB schema files. If you provide a list of tables, only those tables will be imported. For more information about the default file pattern, see [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Limitations:**
	// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
	// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
	// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
	Tables []*ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0 `json:"tables"`
}

// Validate validates this list import tasks o k body items items0 spec target
func (o *ListImportTasksOKBodyItemsItems0SpecTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecTarget) validateTables(formats strfmt.Registry) error {
	if swag.IsZero(o.Tables) { // not required
		return nil
	}

	for i := 0; i < len(o.Tables); i++ {
		if swag.IsZero(o.Tables[i]) { // not required
			continue
		}

		if o.Tables[i] != nil {
			if err := o.Tables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this list import tasks o k body items items0 spec target based on the context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecTarget) contextValidateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Tables); i++ {

		if o.Tables[i] != nil {

			if swag.IsZero(o.Tables[i]) { // not required
				return nil
			}

			if err := o.Tables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecTarget) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecTarget) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0 ImportTargetTable
//
// ImportTargetTable represents the settings for importing source data into a single target table of an import task.
swagger:model ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0
*/
type ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0 struct {

	// The target database name.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
	// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
	// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
	//
	// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
	//
	// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
	//
	// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
	// Example: data/db01/table01.*.csv
	FileNamePattern string `json:"file_name_pattern,omitempty"`

	// The target table name.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this list import tasks o k body items items0 spec target tables items0
func (o *ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this list import tasks o k body items items0 spec target tables items0 based on context it is used
func (o *ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0SpecTargetTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0Status ImportStatus
//
// The status of the import task.
swagger:model ListImportTasksOKBodyItemsItems0Status
*/
type ListImportTasksOKBodyItemsItems0Status struct {

	// The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
	// Example: 1676450897
	EndTimestamp string `json:"end_timestamp,omitempty"`

	// The error message of the import task.
	// Example: some error occurs
	ErrorMessage string `json:"error_message,omitempty"`

	// The current phase that the import task is in.
	// Example: IMPORTING
	// Required: true
	// Enum: ["PREPARING","IMPORTING","COMPLETED","FAILED","CANCELING","CANCELED"]
	Phase *string `json:"phase"`

	// progress
	Progress *ListImportTasksOKBodyItemsItems0StatusProgress `json:"progress,omitempty"`

	// The total size of the import task's data source. The unit is bytes.
	// Example: 10737418240
	SourceTotalSizeBytes string `json:"source_total_size_bytes,omitempty"`

	// The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
	// Example: 1676450597
	StartTimestamp string `json:"start_timestamp,omitempty"`
}

// Validate validates this list import tasks o k body items items0 status
func (o *ListImportTasksOKBodyItemsItems0Status) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePhase(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var listImportTasksOKBodyItemsItems0StatusTypePhasePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PREPARING","IMPORTING","COMPLETED","FAILED","CANCELING","CANCELED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		listImportTasksOKBodyItemsItems0StatusTypePhasePropEnum = append(listImportTasksOKBodyItemsItems0StatusTypePhasePropEnum, v)
	}
}

const (

	// ListImportTasksOKBodyItemsItems0StatusPhasePREPARING captures enum value "PREPARING"
	ListImportTasksOKBodyItemsItems0StatusPhasePREPARING string = "PREPARING"

	// ListImportTasksOKBodyItemsItems0StatusPhaseIMPORTING captures enum value "IMPORTING"
	ListImportTasksOKBodyItemsItems0StatusPhaseIMPORTING string = "IMPORTING"

	// ListImportTasksOKBodyItemsItems0StatusPhaseCOMPLETED captures enum value "COMPLETED"
	ListImportTasksOKBodyItemsItems0StatusPhaseCOMPLETED string = "COMPLETED"

	// ListImportTasksOKBodyItemsItems0StatusPhaseFAILED captures enum value "FAILED"
	ListImportTasksOKBodyItemsItems0StatusPhaseFAILED string = "FAILED"

	// ListImportTasksOKBodyItemsItems0StatusPhaseCANCELING captures enum value "CANCELING"
	ListImportTasksOKBodyItemsItems0StatusPhaseCANCELING string = "CANCELING"

	// ListImportTasksOKBodyItemsItems0StatusPhaseCANCELED captures enum value "CANCELED"
	ListImportTasksOKBodyItemsItems0StatusPhaseCANCELED string = "CANCELED"
)

// prop value enum
func (o *ListImportTasksOKBodyItemsItems0Status) validatePhaseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, listImportTasksOKBodyItemsItems0StatusTypePhasePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Status) validatePhase(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"phase", "body", o.Phase); err != nil {
		return err
	}

	// value enum
	if err := o.validatePhaseEnum("status"+"."+"phase", "body", *o.Phase); err != nil {
		return err
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Status) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(o.Progress) { // not required
		return nil
	}

	if o.Progress != nil {
		if err := o.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this list import tasks o k body items items0 status based on the context it is used
func (o *ListImportTasksOKBodyItemsItems0Status) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0Status) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if o.Progress != nil {

		if swag.IsZero(o.Progress) { // not required
			return nil
		}

		if err := o.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0Status) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0Status) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0Status
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksOKBodyItemsItems0StatusProgress ImportProgress
//
// The progress of the import task.
swagger:model ListImportTasksOKBodyItemsItems0StatusProgress
*/
type ListImportTasksOKBodyItemsItems0StatusProgress struct {

	// The overall importing progress of the import task.
	// Example: 59
	// Required: true
	// Maximum: 100
	ImportProgress *float64 `json:"import_progress"`

	// The overall validation progress of the import task after the data has been imported into the target cluster.
	// Example: 59
	// Required: true
	// Maximum: 100
	ValidationProgress *float64 `json:"validation_progress"`
}

// Validate validates this list import tasks o k body items items0 status progress
func (o *ListImportTasksOKBodyItemsItems0StatusProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateImportProgress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValidationProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ListImportTasksOKBodyItemsItems0StatusProgress) validateImportProgress(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"progress"+"."+"import_progress", "body", o.ImportProgress); err != nil {
		return err
	}

	if err := validate.Maximum("status"+"."+"progress"+"."+"import_progress", "body", *o.ImportProgress, 100, false); err != nil {
		return err
	}

	return nil
}

func (o *ListImportTasksOKBodyItemsItems0StatusProgress) validateValidationProgress(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"progress"+"."+"validation_progress", "body", o.ValidationProgress); err != nil {
		return err
	}

	if err := validate.Maximum("status"+"."+"progress"+"."+"validation_progress", "body", *o.ValidationProgress, 100, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this list import tasks o k body items items0 status progress based on context it is used
func (o *ListImportTasksOKBodyItemsItems0StatusProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0StatusProgress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksOKBodyItemsItems0StatusProgress) UnmarshalBinary(b []byte) error {
	var res ListImportTasksOKBodyItemsItems0StatusProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ListImportTasksTooManyRequestsBody list import tasks too many requests body
swagger:model ListImportTasksTooManyRequestsBody
*/
type ListImportTasksTooManyRequestsBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this list import tasks too many requests body
func (o *ListImportTasksTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this list import tasks too many requests body based on context it is used
func (o *ListImportTasksTooManyRequestsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ListImportTasksTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ListImportTasksTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res ListImportTasksTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
