// Code generated by go-swagger; DO NOT EDIT.

package import_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GetImportTaskReader is a Reader for the GetImportTask structure.
type GetImportTaskReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetImportTaskReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetImportTaskOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewGetImportTaskBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewGetImportTaskUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewGetImportTaskForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewGetImportTaskNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewGetImportTaskTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewGetImportTaskInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewGetImportTaskDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewGetImportTaskOK creates a GetImportTaskOK with default headers values
func NewGetImportTaskOK() *GetImportTaskOK {
	return &GetImportTaskOK{}
}

/*
GetImportTaskOK describes a response with status code 200, with default header values.

A successful response.
*/
type GetImportTaskOK struct {
	Payload *GetImportTaskOKBody
}

// IsSuccess returns true when this get import task o k response has a 2xx status code
func (o *GetImportTaskOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get import task o k response has a 3xx status code
func (o *GetImportTaskOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get import task o k response has a 4xx status code
func (o *GetImportTaskOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get import task o k response has a 5xx status code
func (o *GetImportTaskOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get import task o k response a status code equal to that given
func (o *GetImportTaskOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get import task o k response
func (o *GetImportTaskOK) Code() int {
	return 200
}

func (o *GetImportTaskOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskOK %s", 200, payload)
}

func (o *GetImportTaskOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskOK %s", 200, payload)
}

func (o *GetImportTaskOK) GetPayload() *GetImportTaskOKBody {
	return o.Payload
}

func (o *GetImportTaskOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetImportTaskOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetImportTaskBadRequest creates a GetImportTaskBadRequest with default headers values
func NewGetImportTaskBadRequest() *GetImportTaskBadRequest {
	return &GetImportTaskBadRequest{}
}

/*
GetImportTaskBadRequest describes a response with status code 400, with default header values.

A request field is invalid.
*/
type GetImportTaskBadRequest struct {
	Payload *GetImportTaskBadRequestBody
}

// IsSuccess returns true when this get import task bad request response has a 2xx status code
func (o *GetImportTaskBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get import task bad request response has a 3xx status code
func (o *GetImportTaskBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get import task bad request response has a 4xx status code
func (o *GetImportTaskBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this get import task bad request response has a 5xx status code
func (o *GetImportTaskBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this get import task bad request response a status code equal to that given
func (o *GetImportTaskBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the get import task bad request response
func (o *GetImportTaskBadRequest) Code() int {
	return 400
}

func (o *GetImportTaskBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskBadRequest %s", 400, payload)
}

func (o *GetImportTaskBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskBadRequest %s", 400, payload)
}

func (o *GetImportTaskBadRequest) GetPayload() *GetImportTaskBadRequestBody {
	return o.Payload
}

func (o *GetImportTaskBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetImportTaskBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetImportTaskUnauthorized creates a GetImportTaskUnauthorized with default headers values
func NewGetImportTaskUnauthorized() *GetImportTaskUnauthorized {
	return &GetImportTaskUnauthorized{}
}

/*
GetImportTaskUnauthorized describes a response with status code 401, with default header values.

The API key cannot be authenticated.
*/
type GetImportTaskUnauthorized struct {
	Payload interface{}
}

// IsSuccess returns true when this get import task unauthorized response has a 2xx status code
func (o *GetImportTaskUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get import task unauthorized response has a 3xx status code
func (o *GetImportTaskUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get import task unauthorized response has a 4xx status code
func (o *GetImportTaskUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this get import task unauthorized response has a 5xx status code
func (o *GetImportTaskUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this get import task unauthorized response a status code equal to that given
func (o *GetImportTaskUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the get import task unauthorized response
func (o *GetImportTaskUnauthorized) Code() int {
	return 401
}

func (o *GetImportTaskUnauthorized) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskUnauthorized %s", 401, payload)
}

func (o *GetImportTaskUnauthorized) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskUnauthorized %s", 401, payload)
}

func (o *GetImportTaskUnauthorized) GetPayload() interface{} {
	return o.Payload
}

func (o *GetImportTaskUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetImportTaskForbidden creates a GetImportTaskForbidden with default headers values
func NewGetImportTaskForbidden() *GetImportTaskForbidden {
	return &GetImportTaskForbidden{}
}

/*
GetImportTaskForbidden describes a response with status code 403, with default header values.

The API key does not have permission to access the resource.
*/
type GetImportTaskForbidden struct {
	Payload *GetImportTaskForbiddenBody
}

// IsSuccess returns true when this get import task forbidden response has a 2xx status code
func (o *GetImportTaskForbidden) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get import task forbidden response has a 3xx status code
func (o *GetImportTaskForbidden) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get import task forbidden response has a 4xx status code
func (o *GetImportTaskForbidden) IsClientError() bool {
	return true
}

// IsServerError returns true when this get import task forbidden response has a 5xx status code
func (o *GetImportTaskForbidden) IsServerError() bool {
	return false
}

// IsCode returns true when this get import task forbidden response a status code equal to that given
func (o *GetImportTaskForbidden) IsCode(code int) bool {
	return code == 403
}

// Code gets the status code for the get import task forbidden response
func (o *GetImportTaskForbidden) Code() int {
	return 403
}

func (o *GetImportTaskForbidden) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskForbidden %s", 403, payload)
}

func (o *GetImportTaskForbidden) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskForbidden %s", 403, payload)
}

func (o *GetImportTaskForbidden) GetPayload() *GetImportTaskForbiddenBody {
	return o.Payload
}

func (o *GetImportTaskForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetImportTaskForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetImportTaskNotFound creates a GetImportTaskNotFound with default headers values
func NewGetImportTaskNotFound() *GetImportTaskNotFound {
	return &GetImportTaskNotFound{}
}

/*
GetImportTaskNotFound describes a response with status code 404, with default header values.

The requested resource does not exist.
*/
type GetImportTaskNotFound struct {
	Payload *GetImportTaskNotFoundBody
}

// IsSuccess returns true when this get import task not found response has a 2xx status code
func (o *GetImportTaskNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get import task not found response has a 3xx status code
func (o *GetImportTaskNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get import task not found response has a 4xx status code
func (o *GetImportTaskNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this get import task not found response has a 5xx status code
func (o *GetImportTaskNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this get import task not found response a status code equal to that given
func (o *GetImportTaskNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the get import task not found response
func (o *GetImportTaskNotFound) Code() int {
	return 404
}

func (o *GetImportTaskNotFound) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskNotFound %s", 404, payload)
}

func (o *GetImportTaskNotFound) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskNotFound %s", 404, payload)
}

func (o *GetImportTaskNotFound) GetPayload() *GetImportTaskNotFoundBody {
	return o.Payload
}

func (o *GetImportTaskNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetImportTaskNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetImportTaskTooManyRequests creates a GetImportTaskTooManyRequests with default headers values
func NewGetImportTaskTooManyRequests() *GetImportTaskTooManyRequests {
	return &GetImportTaskTooManyRequests{}
}

/*
GetImportTaskTooManyRequests describes a response with status code 429, with default header values.

You have exceed the rate limit.
*/
type GetImportTaskTooManyRequests struct {
	Payload *GetImportTaskTooManyRequestsBody
}

// IsSuccess returns true when this get import task too many requests response has a 2xx status code
func (o *GetImportTaskTooManyRequests) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get import task too many requests response has a 3xx status code
func (o *GetImportTaskTooManyRequests) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get import task too many requests response has a 4xx status code
func (o *GetImportTaskTooManyRequests) IsClientError() bool {
	return true
}

// IsServerError returns true when this get import task too many requests response has a 5xx status code
func (o *GetImportTaskTooManyRequests) IsServerError() bool {
	return false
}

// IsCode returns true when this get import task too many requests response a status code equal to that given
func (o *GetImportTaskTooManyRequests) IsCode(code int) bool {
	return code == 429
}

// Code gets the status code for the get import task too many requests response
func (o *GetImportTaskTooManyRequests) Code() int {
	return 429
}

func (o *GetImportTaskTooManyRequests) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskTooManyRequests %s", 429, payload)
}

func (o *GetImportTaskTooManyRequests) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskTooManyRequests %s", 429, payload)
}

func (o *GetImportTaskTooManyRequests) GetPayload() *GetImportTaskTooManyRequestsBody {
	return o.Payload
}

func (o *GetImportTaskTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetImportTaskTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetImportTaskInternalServerError creates a GetImportTaskInternalServerError with default headers values
func NewGetImportTaskInternalServerError() *GetImportTaskInternalServerError {
	return &GetImportTaskInternalServerError{}
}

/*
GetImportTaskInternalServerError describes a response with status code 500, with default header values.

Server error.
*/
type GetImportTaskInternalServerError struct {
	Payload *GetImportTaskInternalServerErrorBody
}

// IsSuccess returns true when this get import task internal server error response has a 2xx status code
func (o *GetImportTaskInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get import task internal server error response has a 3xx status code
func (o *GetImportTaskInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get import task internal server error response has a 4xx status code
func (o *GetImportTaskInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this get import task internal server error response has a 5xx status code
func (o *GetImportTaskInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this get import task internal server error response a status code equal to that given
func (o *GetImportTaskInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the get import task internal server error response
func (o *GetImportTaskInternalServerError) Code() int {
	return 500
}

func (o *GetImportTaskInternalServerError) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskInternalServerError %s", 500, payload)
}

func (o *GetImportTaskInternalServerError) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] getImportTaskInternalServerError %s", 500, payload)
}

func (o *GetImportTaskInternalServerError) GetPayload() *GetImportTaskInternalServerErrorBody {
	return o.Payload
}

func (o *GetImportTaskInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetImportTaskInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetImportTaskDefault creates a GetImportTaskDefault with default headers values
func NewGetImportTaskDefault(code int) *GetImportTaskDefault {
	return &GetImportTaskDefault{
		_statusCode: code,
	}
}

/*
GetImportTaskDefault describes a response with status code -1, with default header values.

An unexpected error response.
*/
type GetImportTaskDefault struct {
	_statusCode int

	Payload *GetImportTaskDefaultBody
}

// IsSuccess returns true when this get import task default response has a 2xx status code
func (o *GetImportTaskDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this get import task default response has a 3xx status code
func (o *GetImportTaskDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this get import task default response has a 4xx status code
func (o *GetImportTaskDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this get import task default response has a 5xx status code
func (o *GetImportTaskDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this get import task default response a status code equal to that given
func (o *GetImportTaskDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the get import task default response
func (o *GetImportTaskDefault) Code() int {
	return o._statusCode
}

func (o *GetImportTaskDefault) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] GetImportTask default %s", o._statusCode, payload)
}

func (o *GetImportTaskDefault) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id}][%d] GetImportTask default %s", o._statusCode, payload)
}

func (o *GetImportTaskDefault) GetPayload() *GetImportTaskDefaultBody {
	return o.Payload
}

func (o *GetImportTaskDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetImportTaskDefaultBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
GetImportTaskBadRequestBody get import task bad request body
swagger:model GetImportTaskBadRequestBody
*/
type GetImportTaskBadRequestBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this get import task bad request body
func (o *GetImportTaskBadRequestBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get import task bad request body based on context it is used
func (o *GetImportTaskBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskBadRequestBody) UnmarshalBinary(b []byte) error {
	var res GetImportTaskBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskDefaultBody get import task default body
swagger:model GetImportTaskDefaultBody
*/
type GetImportTaskDefaultBody struct {

	// code
	Code int32 `json:"code,omitempty"`

	// details
	Details []*GetImportTaskDefaultBodyDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`
}

// Validate validates this get import task default body
func (o *GetImportTaskDefaultBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskDefaultBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("GetImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("GetImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get import task default body based on the context it is used
func (o *GetImportTaskDefaultBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskDefaultBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("GetImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("GetImportTask default" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskDefaultBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskDefaultBody) UnmarshalBinary(b []byte) error {
	var res GetImportTaskDefaultBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskDefaultBodyDetailsItems0 get import task default body details items0
swagger:model GetImportTaskDefaultBodyDetailsItems0
*/
type GetImportTaskDefaultBodyDetailsItems0 struct {

	// at type
	AtType string `json:"@type,omitempty"`

	// get import task default body details items0
	GetImportTaskDefaultBodyDetailsItems0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (o *GetImportTaskDefaultBodyDetailsItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// at type
		AtType string `json:"@type,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv GetImportTaskDefaultBodyDetailsItems0

	rcv.AtType = stage1.AtType
	*o = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "@type")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		o.GetImportTaskDefaultBodyDetailsItems0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (o GetImportTaskDefaultBodyDetailsItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// at type
		AtType string `json:"@type,omitempty"`
	}

	stage1.AtType = o.AtType

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(o.GetImportTaskDefaultBodyDetailsItems0) == 0 { // no additional properties
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(o.GetImportTaskDefaultBodyDetailsItems0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 { // "{}": only additional properties
		return additional, nil
	}

	// concatenate the 2 objects
	return swag.ConcatJSON(props, additional), nil
}

// Validate validates this get import task default body details items0
func (o *GetImportTaskDefaultBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get import task default body details items0 based on context it is used
func (o *GetImportTaskDefaultBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskDefaultBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskDefaultBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetImportTaskDefaultBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskForbiddenBody get import task forbidden body
swagger:model GetImportTaskForbiddenBody
*/
type GetImportTaskForbiddenBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this get import task forbidden body
func (o *GetImportTaskForbiddenBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get import task forbidden body based on context it is used
func (o *GetImportTaskForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskForbiddenBody) UnmarshalBinary(b []byte) error {
	var res GetImportTaskForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskInternalServerErrorBody get import task internal server error body
swagger:model GetImportTaskInternalServerErrorBody
*/
type GetImportTaskInternalServerErrorBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this get import task internal server error body
func (o *GetImportTaskInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get import task internal server error body based on context it is used
func (o *GetImportTaskInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res GetImportTaskInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskNotFoundBody get import task not found body
swagger:model GetImportTaskNotFoundBody
*/
type GetImportTaskNotFoundBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this get import task not found body
func (o *GetImportTaskNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get import task not found body based on context it is used
func (o *GetImportTaskNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskNotFoundBody) UnmarshalBinary(b []byte) error {
	var res GetImportTaskNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBody ImportItem
//
// ImportItem represents the information of a single import task.
swagger:model GetImportTaskOKBody
*/
type GetImportTaskOKBody struct {

	// metadata
	Metadata *GetImportTaskOKBodyMetadata `json:"metadata,omitempty"`

	// spec
	Spec *GetImportTaskOKBodySpec `json:"spec,omitempty"`

	// status
	Status *GetImportTaskOKBodyStatus `json:"status,omitempty"`
}

// Validate validates this get import task o k body
func (o *GetImportTaskOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBody) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBody) validateSpec(formats strfmt.Registry) error {
	if swag.IsZero(o.Spec) { // not required
		return nil
	}

	if o.Spec != nil {
		if err := o.Spec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBody) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.Status) { // not required
		return nil
	}

	if o.Status != nil {
		if err := o.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get import task o k body based on the context it is used
func (o *GetImportTaskOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBody) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {

		if swag.IsZero(o.Metadata) { // not required
			return nil
		}

		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBody) contextValidateSpec(ctx context.Context, formats strfmt.Registry) error {

	if o.Spec != nil {

		if swag.IsZero(o.Spec) { // not required
			return nil
		}

		if err := o.Spec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBody) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if o.Status != nil {

		if swag.IsZero(o.Status) { // not required
			return nil
		}

		if err := o.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBody) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodyMetadata ImportMetadata
//
// The metadata of the import task.
swagger:model GetImportTaskOKBodyMetadata
*/
type GetImportTaskOKBodyMetadata struct {

	// The creation time of the import task in Unix timestamp seconds (epoch time).
	// Example: 1676450597
	// Required: true
	CreateTimestamp *string `json:"create_timestamp"`

	// The ID of the import task.
	// Example: 1
	// Required: true
	ID *string `json:"id"`

	// The name of the import task.
	// Example: my_import
	Name string `json:"name,omitempty"`
}

// Validate validates this get import task o k body metadata
func (o *GetImportTaskOKBodyMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCreateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodyMetadata) validateCreateTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"metadata"+"."+"create_timestamp", "body", o.CreateTimestamp); err != nil {
		return err
	}

	return nil
}

func (o *GetImportTaskOKBodyMetadata) validateID(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"metadata"+"."+"id", "body", o.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get import task o k body metadata based on context it is used
func (o *GetImportTaskOKBodyMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodyMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodyMetadata) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodyMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpec ImportSpec
//
// The specification of the import task.
swagger:model GetImportTaskOKBodySpec
*/
type GetImportTaskOKBodySpec struct {

	// source
	// Required: true
	Source *GetImportTaskOKBodySpecSource `json:"source"`

	// target
	// Required: true
	Target *GetImportTaskOKBodySpecTarget `json:"target"`
}

// Validate validates this get import task o k body spec
func (o *GetImportTaskOKBodySpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpec) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source", "body", o.Source); err != nil {
		return err
	}

	if o.Source != nil {
		if err := o.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpec) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"target", "body", o.Target); err != nil {
		return err
	}

	if o.Target != nil {
		if err := o.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get import task o k body spec based on the context it is used
func (o *GetImportTaskOKBodySpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpec) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if o.Source != nil {

		if err := o.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpec) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if o.Target != nil {

		if err := o.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpec) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpec) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecSource ImportSource
//
// The data source settings of the import task.
swagger:model GetImportTaskOKBodySpecSource
*/
type GetImportTaskOKBodySpecSource struct {

	// aws assume role access
	AwsAssumeRoleAccess *GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess `json:"aws_assume_role_access,omitempty"`

	// aws key access
	AwsKeyAccess *GetImportTaskOKBodySpecSourceAwsKeyAccess `json:"aws_key_access,omitempty"`

	// azure token access
	AzureTokenAccess *GetImportTaskOKBodySpecSourceAzureTokenAccess `json:"azure_token_access,omitempty"`

	// format
	// Required: true
	Format *GetImportTaskOKBodySpecSourceFormat `json:"format"`

	// The data source type of an import task.
	//
	// - `"S3"`: import data from Amazon S3
	// - `"GCS"`: import data from Google Cloud Storage
	// - `"LOCAL_FILE"`: import data from a local file (only available for [TiDB Cloud Serverless](https://docs.pingcap.com/tidbcloud/select-cluster-tier#tidb-cloud-serverless) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
	//
	// **Note:** Currently, if this import spec is used for a [preview](#tag/Import/operation/PreviewImportData) request, only the `LOCAL_FILE` source type is supported.
	// Example: S3
	// Required: true
	// Enum: ["S3","GCS","LOCAL_FILE","AZBLOB"]
	Type *string `json:"type"`

	// The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
	// * `S3`: `s3://`
	// * `GCS`: `gs://`
	// * `LOCAL_FILE`: `file://`.
	//
	// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
	//
	// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
	// Example: s3://example-bucket/example-source-data/
	// Required: true
	URI *string `json:"uri"`
}

// Validate validates this get import task o k body spec source
func (o *GetImportTaskOKBodySpecSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAwsAssumeRoleAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAwsKeyAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAzureTokenAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSource) validateAwsAssumeRoleAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
		return nil
	}

	if o.AwsAssumeRoleAccess != nil {
		if err := o.AwsAssumeRoleAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSource) validateAwsKeyAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AwsKeyAccess) { // not required
		return nil
	}

	if o.AwsKeyAccess != nil {
		if err := o.AwsKeyAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSource) validateAzureTokenAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.AzureTokenAccess) { // not required
		return nil
	}

	if o.AzureTokenAccess != nil {
		if err := o.AzureTokenAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSource) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"format", "body", o.Format); err != nil {
		return err
	}

	if o.Format != nil {
		if err := o.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

var getImportTaskOKBodySpecSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","GCS","LOCAL_FILE","AZBLOB"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getImportTaskOKBodySpecSourceTypeTypePropEnum = append(getImportTaskOKBodySpecSourceTypeTypePropEnum, v)
	}
}

const (

	// GetImportTaskOKBodySpecSourceTypeS3 captures enum value "S3"
	GetImportTaskOKBodySpecSourceTypeS3 string = "S3"

	// GetImportTaskOKBodySpecSourceTypeGCS captures enum value "GCS"
	GetImportTaskOKBodySpecSourceTypeGCS string = "GCS"

	// GetImportTaskOKBodySpecSourceTypeLOCALFILE captures enum value "LOCAL_FILE"
	GetImportTaskOKBodySpecSourceTypeLOCALFILE string = "LOCAL_FILE"

	// GetImportTaskOKBodySpecSourceTypeAZBLOB captures enum value "AZBLOB"
	GetImportTaskOKBodySpecSourceTypeAZBLOB string = "AZBLOB"
)

// prop value enum
func (o *GetImportTaskOKBodySpecSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, getImportTaskOKBodySpecSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSource) validateType(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSource) validateURI(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"uri", "body", o.URI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get import task o k body spec source based on the context it is used
func (o *GetImportTaskOKBodySpecSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAwsAssumeRoleAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAwsKeyAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAzureTokenAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSource) contextValidateAwsAssumeRoleAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsAssumeRoleAccess != nil {

		if swag.IsZero(o.AwsAssumeRoleAccess) { // not required
			return nil
		}

		if err := o.AwsAssumeRoleAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSource) contextValidateAwsKeyAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AwsKeyAccess != nil {

		if swag.IsZero(o.AwsKeyAccess) { // not required
			return nil
		}

		if err := o.AwsKeyAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSource) contextValidateAzureTokenAccess(ctx context.Context, formats strfmt.Registry) error {

	if o.AzureTokenAccess != nil {

		if swag.IsZero(o.AzureTokenAccess) { // not required
			return nil
		}

		if err := o.AzureTokenAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "azure_token_access")
			}
			return err
		}
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSource) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if o.Format != nil {

		if err := o.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSource) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSource) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess AwsAssumeRoleAccess
//
// The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess
*/
type GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess struct {

	// The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
	// Example: arn:aws:iam::999999999999:role/sample-role
	// Required: true
	AssumeRole *string `json:"assume_role"`
}

// Validate validates this get import task o k body spec source aws assume role access
func (o *GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssumeRole(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess) validateAssumeRole(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"aws_assume_role_access"+"."+"assume_role", "body", o.AssumeRole); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get import task o k body spec source aws assume role access based on context it is used
func (o *GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecSourceAwsAssumeRoleAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecSourceAwsKeyAccess AwsKeyAccess
//
// The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
swagger:model GetImportTaskOKBodySpecSourceAwsKeyAccess
*/
type GetImportTaskOKBodySpecSourceAwsKeyAccess struct {

	// The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_ACCESS_KEY_ID
	// Required: true
	AccessKeyID *string `json:"access_key_id"`

	// The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SECRET_ACCESS_KEY
	// Required: true
	SecretAccessKey *string `json:"secret_access_key"`
}

// Validate validates this get import task o k body spec source aws key access
func (o *GetImportTaskOKBodySpecSourceAwsKeyAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccessKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecretAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSourceAwsKeyAccess) validateAccessKeyID(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"access_key_id", "body", o.AccessKeyID); err != nil {
		return err
	}

	return nil
}

func (o *GetImportTaskOKBodySpecSourceAwsKeyAccess) validateSecretAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"aws_key_access"+"."+"secret_access_key", "body", o.SecretAccessKey); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get import task o k body spec source aws key access based on context it is used
func (o *GetImportTaskOKBodySpecSourceAwsKeyAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceAwsKeyAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceAwsKeyAccess) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecSourceAwsKeyAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecSourceAzureTokenAccess AzureTokenAccess
//
// The settings to access the Azblob data with an sas token. This field is only needed if you want to access the Azblob data with an sas token.
swagger:model GetImportTaskOKBodySpecSourceAzureTokenAccess
*/
type GetImportTaskOKBodySpecSourceAzureTokenAccess struct {

	// The sas token to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SAS_TOKEN
	// Required: true
	SasToken *string `json:"sas_token"`
}

// Validate validates this get import task o k body spec source azure token access
func (o *GetImportTaskOKBodySpecSourceAzureTokenAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSasToken(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSourceAzureTokenAccess) validateSasToken(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"azure_token_access"+"."+"sas_token", "body", o.SasToken); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get import task o k body spec source azure token access based on context it is used
func (o *GetImportTaskOKBodySpecSourceAzureTokenAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceAzureTokenAccess) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceAzureTokenAccess) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecSourceAzureTokenAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecSourceFormat ImportSourceFormat
//
// The format settings of the import data source.
swagger:model GetImportTaskOKBodySpecSourceFormat
*/
type GetImportTaskOKBodySpecSourceFormat struct {

	// csv config
	CsvConfig *GetImportTaskOKBodySpecSourceFormatCsvConfig `json:"csv_config,omitempty"`

	// The format type of an import source.
	// Example: CSV
	// Required: true
	// Enum: ["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]
	Type *string `json:"type"`
}

// Validate validates this get import task o k body spec source format
func (o *GetImportTaskOKBodySpecSourceFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCsvConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSourceFormat) validateCsvConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.CsvConfig) { // not required
		return nil
	}

	if o.CsvConfig != nil {
		if err := o.CsvConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

var getImportTaskOKBodySpecSourceFormatTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getImportTaskOKBodySpecSourceFormatTypeTypePropEnum = append(getImportTaskOKBodySpecSourceFormatTypeTypePropEnum, v)
	}
}

const (

	// GetImportTaskOKBodySpecSourceFormatTypeCSV captures enum value "CSV"
	GetImportTaskOKBodySpecSourceFormatTypeCSV string = "CSV"

	// GetImportTaskOKBodySpecSourceFormatTypePARQUET captures enum value "PARQUET"
	GetImportTaskOKBodySpecSourceFormatTypePARQUET string = "PARQUET"

	// GetImportTaskOKBodySpecSourceFormatTypeSQL captures enum value "SQL"
	GetImportTaskOKBodySpecSourceFormatTypeSQL string = "SQL"

	// GetImportTaskOKBodySpecSourceFormatTypeAURORASNAPSHOT captures enum value "AURORA_SNAPSHOT"
	GetImportTaskOKBodySpecSourceFormatTypeAURORASNAPSHOT string = "AURORA_SNAPSHOT"
)

// prop value enum
func (o *GetImportTaskOKBodySpecSourceFormat) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, getImportTaskOKBodySpecSourceFormatTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSourceFormat) validateType(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("getImportTaskOK"+"."+"spec"+"."+"source"+"."+"format"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get import task o k body spec source format based on the context it is used
func (o *GetImportTaskOKBodySpecSourceFormat) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCsvConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecSourceFormat) contextValidateCsvConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.CsvConfig != nil {

		if swag.IsZero(o.CsvConfig) { // not required
			return nil
		}

		if err := o.CsvConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceFormat) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceFormat) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecSourceFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecSourceFormatCsvConfig ImportSourceCSVConfig
//
// The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
swagger:model GetImportTaskOKBodySpecSourceFormatCsvConfig
*/
type GetImportTaskOKBodySpecSourceFormatCsvConfig struct {

	// Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
	//
	// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
	BackslashEscape *bool `json:"backslash_escape,omitempty"`

	// The delimiter character used to separate fields in the CSV data.
	Delimiter *string `json:"delimiter,omitempty"`

	// Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
	HasHeaderRow *bool `json:"has_header_row,omitempty"`

	// The character used to quote the fields in the CSV data.
	Quote *string `json:"quote,omitempty"`
}

// Validate validates this get import task o k body spec source format csv config
func (o *GetImportTaskOKBodySpecSourceFormatCsvConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get import task o k body spec source format csv config based on context it is used
func (o *GetImportTaskOKBodySpecSourceFormatCsvConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceFormatCsvConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecSourceFormatCsvConfig) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecSourceFormatCsvConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecTarget ImportTarget
//
// The target settings of the import task.
swagger:model GetImportTaskOKBodySpecTarget
*/
type GetImportTaskOKBodySpecTarget struct {

	// The settings for each target table that is being imported for the import task. If you leave it empty, the system will scan all the files in the data source using the default file patterns and collect all the tables to import. The files include data files, table schema files, and DB schema files. If you provide a list of tables, only those tables will be imported. For more information about the default file pattern, see [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Limitations:**
	// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
	// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
	// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
	Tables []*GetImportTaskOKBodySpecTargetTablesItems0 `json:"tables"`
}

// Validate validates this get import task o k body spec target
func (o *GetImportTaskOKBodySpecTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecTarget) validateTables(formats strfmt.Registry) error {
	if swag.IsZero(o.Tables) { // not required
		return nil
	}

	for i := 0; i < len(o.Tables); i++ {
		if swag.IsZero(o.Tables[i]) { // not required
			continue
		}

		if o.Tables[i] != nil {
			if err := o.Tables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get import task o k body spec target based on the context it is used
func (o *GetImportTaskOKBodySpecTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecTarget) contextValidateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Tables); i++ {

		if o.Tables[i] != nil {

			if swag.IsZero(o.Tables[i]) { // not required
				return nil
			}

			if err := o.Tables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getImportTaskOK" + "." + "spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecTarget) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecTarget) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodySpecTargetTablesItems0 ImportTargetTable
//
// ImportTargetTable represents the settings for importing source data into a single target table of an import task.
swagger:model GetImportTaskOKBodySpecTargetTablesItems0
*/
type GetImportTaskOKBodySpecTargetTablesItems0 struct {

	// The target database name.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
	// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
	// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
	//
	// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
	//
	// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
	//
	// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
	// Example: data/db01/table01.*.csv
	FileNamePattern string `json:"file_name_pattern,omitempty"`

	// The target table name.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this get import task o k body spec target tables items0
func (o *GetImportTaskOKBodySpecTargetTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodySpecTargetTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", o.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (o *GetImportTaskOKBodySpecTargetTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", o.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get import task o k body spec target tables items0 based on context it is used
func (o *GetImportTaskOKBodySpecTargetTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecTargetTablesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodySpecTargetTablesItems0) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodySpecTargetTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodyStatus ImportStatus
//
// The status of the import task.
swagger:model GetImportTaskOKBodyStatus
*/
type GetImportTaskOKBodyStatus struct {

	// The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
	// Example: 1676450897
	EndTimestamp string `json:"end_timestamp,omitempty"`

	// The error message of the import task.
	// Example: some error occurs
	ErrorMessage string `json:"error_message,omitempty"`

	// The current phase that the import task is in.
	// Example: IMPORTING
	// Required: true
	// Enum: ["PREPARING","IMPORTING","COMPLETED","FAILED","CANCELING","CANCELED"]
	Phase *string `json:"phase"`

	// progress
	Progress *GetImportTaskOKBodyStatusProgress `json:"progress,omitempty"`

	// The total size of the import task's data source. The unit is bytes.
	// Example: 10737418240
	SourceTotalSizeBytes string `json:"source_total_size_bytes,omitempty"`

	// The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
	// Example: 1676450597
	StartTimestamp string `json:"start_timestamp,omitempty"`
}

// Validate validates this get import task o k body status
func (o *GetImportTaskOKBodyStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePhase(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var getImportTaskOKBodyStatusTypePhasePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PREPARING","IMPORTING","COMPLETED","FAILED","CANCELING","CANCELED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getImportTaskOKBodyStatusTypePhasePropEnum = append(getImportTaskOKBodyStatusTypePhasePropEnum, v)
	}
}

const (

	// GetImportTaskOKBodyStatusPhasePREPARING captures enum value "PREPARING"
	GetImportTaskOKBodyStatusPhasePREPARING string = "PREPARING"

	// GetImportTaskOKBodyStatusPhaseIMPORTING captures enum value "IMPORTING"
	GetImportTaskOKBodyStatusPhaseIMPORTING string = "IMPORTING"

	// GetImportTaskOKBodyStatusPhaseCOMPLETED captures enum value "COMPLETED"
	GetImportTaskOKBodyStatusPhaseCOMPLETED string = "COMPLETED"

	// GetImportTaskOKBodyStatusPhaseFAILED captures enum value "FAILED"
	GetImportTaskOKBodyStatusPhaseFAILED string = "FAILED"

	// GetImportTaskOKBodyStatusPhaseCANCELING captures enum value "CANCELING"
	GetImportTaskOKBodyStatusPhaseCANCELING string = "CANCELING"

	// GetImportTaskOKBodyStatusPhaseCANCELED captures enum value "CANCELED"
	GetImportTaskOKBodyStatusPhaseCANCELED string = "CANCELED"
)

// prop value enum
func (o *GetImportTaskOKBodyStatus) validatePhaseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, getImportTaskOKBodyStatusTypePhasePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *GetImportTaskOKBodyStatus) validatePhase(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"status"+"."+"phase", "body", o.Phase); err != nil {
		return err
	}

	// value enum
	if err := o.validatePhaseEnum("getImportTaskOK"+"."+"status"+"."+"phase", "body", *o.Phase); err != nil {
		return err
	}

	return nil
}

func (o *GetImportTaskOKBodyStatus) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(o.Progress) { // not required
		return nil
	}

	if o.Progress != nil {
		if err := o.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get import task o k body status based on the context it is used
func (o *GetImportTaskOKBodyStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodyStatus) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if o.Progress != nil {

		if swag.IsZero(o.Progress) { // not required
			return nil
		}

		if err := o.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getImportTaskOK" + "." + "status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getImportTaskOK" + "." + "status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodyStatus) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodyStatus) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodyStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskOKBodyStatusProgress ImportProgress
//
// The progress of the import task.
swagger:model GetImportTaskOKBodyStatusProgress
*/
type GetImportTaskOKBodyStatusProgress struct {

	// The overall importing progress of the import task.
	// Example: 59
	// Required: true
	// Maximum: 100
	ImportProgress *float64 `json:"import_progress"`

	// The overall validation progress of the import task after the data has been imported into the target cluster.
	// Example: 59
	// Required: true
	// Maximum: 100
	ValidationProgress *float64 `json:"validation_progress"`
}

// Validate validates this get import task o k body status progress
func (o *GetImportTaskOKBodyStatusProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateImportProgress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValidationProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetImportTaskOKBodyStatusProgress) validateImportProgress(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"status"+"."+"progress"+"."+"import_progress", "body", o.ImportProgress); err != nil {
		return err
	}

	if err := validate.Maximum("getImportTaskOK"+"."+"status"+"."+"progress"+"."+"import_progress", "body", *o.ImportProgress, 100, false); err != nil {
		return err
	}

	return nil
}

func (o *GetImportTaskOKBodyStatusProgress) validateValidationProgress(formats strfmt.Registry) error {

	if err := validate.Required("getImportTaskOK"+"."+"status"+"."+"progress"+"."+"validation_progress", "body", o.ValidationProgress); err != nil {
		return err
	}

	if err := validate.Maximum("getImportTaskOK"+"."+"status"+"."+"progress"+"."+"validation_progress", "body", *o.ValidationProgress, 100, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get import task o k body status progress based on context it is used
func (o *GetImportTaskOKBodyStatusProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskOKBodyStatusProgress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskOKBodyStatusProgress) UnmarshalBinary(b []byte) error {
	var res GetImportTaskOKBodyStatusProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetImportTaskTooManyRequestsBody get import task too many requests body
swagger:model GetImportTaskTooManyRequestsBody
*/
type GetImportTaskTooManyRequestsBody struct {

	// code
	//
	// Error code returned with this error.
	Code int64 `json:"code,omitempty"`

	// details
	//
	// Error details returned with this error.
	Details []string `json:"details"`

	// message
	//
	// Error message returned with this error.
	Message string `json:"message,omitempty"`
}

// Validate validates this get import task too many requests body
func (o *GetImportTaskTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get import task too many requests body based on context it is used
func (o *GetImportTaskTooManyRequestsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetImportTaskTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetImportTaskTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res GetImportTaskTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
