// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OpenapiImportItem ImportItem
//
// ImportItem represents the information of a single import task.
//
// swagger:model openapiImportItem
type OpenapiImportItem struct {

	// metadata
	Metadata *OpenapiImportItemMetadata `json:"metadata,omitempty"`

	// spec
	Spec *OpenapiImportItemSpec `json:"spec,omitempty"`

	// status
	Status *OpenapiImportItemStatus `json:"status,omitempty"`
}

// Validate validates this openapi import item
func (m *OpenapiImportItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItem) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItem) validateSpec(formats strfmt.Registry) error {
	if swag.IsZero(m.Spec) { // not required
		return nil
	}

	if m.Spec != nil {
		if err := m.Spec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItem) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this openapi import item based on the context it is used
func (m *OpenapiImportItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItem) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {

		if swag.IsZero(m.Metadata) { // not required
			return nil
		}

		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItem) contextValidateSpec(ctx context.Context, formats strfmt.Registry) error {

	if m.Spec != nil {

		if swag.IsZero(m.Spec) { // not required
			return nil
		}

		if err := m.Spec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItem) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {

		if swag.IsZero(m.Status) { // not required
			return nil
		}

		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItem) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemMetadata ImportMetadata
//
// The metadata of the import task.
//
// swagger:model OpenapiImportItemMetadata
type OpenapiImportItemMetadata struct {

	// The creation time of the import task in Unix timestamp seconds (epoch time).
	// Example: 1676450597
	// Required: true
	CreateTimestamp *string `json:"create_timestamp"`

	// The ID of the import task.
	// Example: 1
	// Required: true
	ID *string `json:"id"`

	// The name of the import task.
	// Example: my_import
	Name string `json:"name,omitempty"`
}

// Validate validates this openapi import item metadata
func (m *OpenapiImportItemMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemMetadata) validateCreateTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("metadata"+"."+"create_timestamp", "body", m.CreateTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiImportItemMetadata) validateID(formats strfmt.Registry) error {

	if err := validate.Required("metadata"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi import item metadata based on context it is used
func (m *OpenapiImportItemMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemMetadata) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpec ImportSpec
//
// The specification of the import task.
//
// swagger:model OpenapiImportItemSpec
type OpenapiImportItemSpec struct {

	// source
	// Required: true
	Source *OpenapiImportItemSpecSource `json:"source"`

	// target
	// Required: true
	Target *OpenapiImportItemSpecTarget `json:"target"`
}

// Validate validates this openapi import item spec
func (m *OpenapiImportItemSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpec) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source", "body", m.Source); err != nil {
		return err
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItemSpec) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"target", "body", m.Target); err != nil {
		return err
	}

	if m.Target != nil {
		if err := m.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this openapi import item spec based on the context it is used
func (m *OpenapiImportItemSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpec) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {

		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItemSpec) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if m.Target != nil {

		if err := m.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpec) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpecSource ImportSource
//
// The data source settings of the import task.
//
// swagger:model OpenapiImportItemSpecSource
type OpenapiImportItemSpecSource struct {

	// aws assume role access
	AwsAssumeRoleAccess *OpenapiImportItemSpecSourceAwsAssumeRoleAccess `json:"aws_assume_role_access,omitempty"`

	// aws key access
	AwsKeyAccess *OpenapiImportItemSpecSourceAwsKeyAccess `json:"aws_key_access,omitempty"`

	// format
	// Required: true
	Format *OpenapiImportItemSpecSourceFormat `json:"format"`

	// The data source type of an import task.
	//
	// - `"S3"`: import data from Amazon S3
	// - `"GCS"`: import data from Google Cloud Storage
	// - `"LOCAL_FILE"`: import data from a local file (only available for [TiDB Serverless](https://docs.pingcap.com/tidbcloud/select-cluster-tier#tidb-serverless) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
	//
	// **Note:** Currently, if this import spec is used for a [preview](#tag/Import/operation/PreviewImportData) request, only the `LOCAL_FILE` source type is supported.
	// Example: S3
	// Required: true
	// Enum: [S3 GCS LOCAL_FILE]
	Type *string `json:"type"`

	// The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
	// * `S3`: `s3://`
	// * `GCS`: `gs://`
	// * `LOCAL_FILE`: `file://`.
	//
	// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
	//
	// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
	// Example: s3://example-bucket/example-source-data/
	// Required: true
	URI *string `json:"uri"`
}

// Validate validates this openapi import item spec source
func (m *OpenapiImportItemSpecSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAwsAssumeRoleAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsKeyAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecSource) validateAwsAssumeRoleAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsAssumeRoleAccess) { // not required
		return nil
	}

	if m.AwsAssumeRoleAccess != nil {
		if err := m.AwsAssumeRoleAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItemSpecSource) validateAwsKeyAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsKeyAccess) { // not required
		return nil
	}

	if m.AwsKeyAccess != nil {
		if err := m.AwsKeyAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItemSpecSource) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"format", "body", m.Format); err != nil {
		return err
	}

	if m.Format != nil {
		if err := m.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

var openapiImportItemSpecSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","GCS","LOCAL_FILE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		openapiImportItemSpecSourceTypeTypePropEnum = append(openapiImportItemSpecSourceTypeTypePropEnum, v)
	}
}

const (

	// OpenapiImportItemSpecSourceTypeS3 captures enum value "S3"
	OpenapiImportItemSpecSourceTypeS3 string = "S3"

	// OpenapiImportItemSpecSourceTypeGCS captures enum value "GCS"
	OpenapiImportItemSpecSourceTypeGCS string = "GCS"

	// OpenapiImportItemSpecSourceTypeLOCALFILE captures enum value "LOCAL_FILE"
	OpenapiImportItemSpecSourceTypeLOCALFILE string = "LOCAL_FILE"
)

// prop value enum
func (m *OpenapiImportItemSpecSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, openapiImportItemSpecSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OpenapiImportItemSpecSource) validateType(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("spec"+"."+"source"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiImportItemSpecSource) validateURI(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"uri", "body", m.URI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this openapi import item spec source based on the context it is used
func (m *OpenapiImportItemSpecSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAwsAssumeRoleAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAwsKeyAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecSource) contextValidateAwsAssumeRoleAccess(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsAssumeRoleAccess != nil {

		if swag.IsZero(m.AwsAssumeRoleAccess) { // not required
			return nil
		}

		if err := m.AwsAssumeRoleAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItemSpecSource) contextValidateAwsKeyAccess(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsKeyAccess != nil {

		if swag.IsZero(m.AwsKeyAccess) { // not required
			return nil
		}

		if err := m.AwsKeyAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiImportItemSpecSource) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if m.Format != nil {

		if err := m.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpecSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpecSource) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpecSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpecSourceAwsAssumeRoleAccess AwsAssumeRoleAccess
//
// The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
//
// swagger:model OpenapiImportItemSpecSourceAwsAssumeRoleAccess
type OpenapiImportItemSpecSourceAwsAssumeRoleAccess struct {

	// The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
	// Example: arn:aws:iam::999999999999:role/sample-role
	// Required: true
	AssumeRole *string `json:"assume_role"`
}

// Validate validates this openapi import item spec source aws assume role access
func (m *OpenapiImportItemSpecSourceAwsAssumeRoleAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssumeRole(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecSourceAwsAssumeRoleAccess) validateAssumeRole(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_assume_role_access"+"."+"assume_role", "body", m.AssumeRole); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi import item spec source aws assume role access based on context it is used
func (m *OpenapiImportItemSpecSourceAwsAssumeRoleAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceAwsAssumeRoleAccess) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceAwsAssumeRoleAccess) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpecSourceAwsAssumeRoleAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpecSourceAwsKeyAccess AwsKeyAccess
//
// The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
//
// swagger:model OpenapiImportItemSpecSourceAwsKeyAccess
type OpenapiImportItemSpecSourceAwsKeyAccess struct {

	// The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_ACCESS_KEY_ID
	// Required: true
	AccessKeyID *string `json:"access_key_id"`

	// The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SECRET_ACCESS_KEY
	// Required: true
	SecretAccessKey *string `json:"secret_access_key"`
}

// Validate validates this openapi import item spec source aws key access
func (m *OpenapiImportItemSpecSourceAwsKeyAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecretAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecSourceAwsKeyAccess) validateAccessKeyID(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_key_access"+"."+"access_key_id", "body", m.AccessKeyID); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiImportItemSpecSourceAwsKeyAccess) validateSecretAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_key_access"+"."+"secret_access_key", "body", m.SecretAccessKey); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi import item spec source aws key access based on context it is used
func (m *OpenapiImportItemSpecSourceAwsKeyAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceAwsKeyAccess) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceAwsKeyAccess) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpecSourceAwsKeyAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpecSourceFormat ImportSourceFormat
//
// The format settings of the import data source.
//
// swagger:model OpenapiImportItemSpecSourceFormat
type OpenapiImportItemSpecSourceFormat struct {

	// csv config
	CsvConfig *OpenapiImportItemSpecSourceFormatCsvConfig `json:"csv_config,omitempty"`

	// The format type of an import source.
	// Example: CSV
	// Required: true
	// Enum: [CSV PARQUET SQL AURORA_SNAPSHOT]
	Type *string `json:"type"`
}

// Validate validates this openapi import item spec source format
func (m *OpenapiImportItemSpecSourceFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCsvConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecSourceFormat) validateCsvConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.CsvConfig) { // not required
		return nil
	}

	if m.CsvConfig != nil {
		if err := m.CsvConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

var openapiImportItemSpecSourceFormatTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		openapiImportItemSpecSourceFormatTypeTypePropEnum = append(openapiImportItemSpecSourceFormatTypeTypePropEnum, v)
	}
}

const (

	// OpenapiImportItemSpecSourceFormatTypeCSV captures enum value "CSV"
	OpenapiImportItemSpecSourceFormatTypeCSV string = "CSV"

	// OpenapiImportItemSpecSourceFormatTypePARQUET captures enum value "PARQUET"
	OpenapiImportItemSpecSourceFormatTypePARQUET string = "PARQUET"

	// OpenapiImportItemSpecSourceFormatTypeSQL captures enum value "SQL"
	OpenapiImportItemSpecSourceFormatTypeSQL string = "SQL"

	// OpenapiImportItemSpecSourceFormatTypeAURORASNAPSHOT captures enum value "AURORA_SNAPSHOT"
	OpenapiImportItemSpecSourceFormatTypeAURORASNAPSHOT string = "AURORA_SNAPSHOT"
)

// prop value enum
func (m *OpenapiImportItemSpecSourceFormat) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, openapiImportItemSpecSourceFormatTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OpenapiImportItemSpecSourceFormat) validateType(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"format"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("spec"+"."+"source"+"."+"format"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this openapi import item spec source format based on the context it is used
func (m *OpenapiImportItemSpecSourceFormat) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCsvConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecSourceFormat) contextValidateCsvConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.CsvConfig != nil {

		if swag.IsZero(m.CsvConfig) { // not required
			return nil
		}

		if err := m.CsvConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceFormat) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceFormat) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpecSourceFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpecSourceFormatCsvConfig ImportSourceCSVConfig
//
// The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
//
// swagger:model OpenapiImportItemSpecSourceFormatCsvConfig
type OpenapiImportItemSpecSourceFormatCsvConfig struct {

	// Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
	//
	// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
	BackslashEscape *bool `json:"backslash_escape,omitempty"`

	// The delimiter character used to separate fields in the CSV data.
	Delimiter *string `json:"delimiter,omitempty"`

	// Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
	HasHeaderRow *bool `json:"has_header_row,omitempty"`

	// The character used to quote the fields in the CSV data.
	Quote *string `json:"quote,omitempty"`
}

// Validate validates this openapi import item spec source format csv config
func (m *OpenapiImportItemSpecSourceFormatCsvConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this openapi import item spec source format csv config based on context it is used
func (m *OpenapiImportItemSpecSourceFormatCsvConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceFormatCsvConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpecSourceFormatCsvConfig) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpecSourceFormatCsvConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpecTarget ImportTarget
//
// The target settings of the import task.
//
// swagger:model OpenapiImportItemSpecTarget
type OpenapiImportItemSpecTarget struct {

	// The settings for each target table that is being imported for the import task. If you leave it empty, the system will scan all the files in the data source using the default file patterns and collect all the tables to import. The files include data files, table schema files, and DB schema files. If you provide a list of tables, only those tables will be imported. For more information about the default file pattern, see [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Limitations:**
	// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
	// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
	// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
	Tables []*OpenapiImportItemSpecTargetTablesItems0 `json:"tables"`
}

// Validate validates this openapi import item spec target
func (m *OpenapiImportItemSpecTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecTarget) validateTables(formats strfmt.Registry) error {
	if swag.IsZero(m.Tables) { // not required
		return nil
	}

	for i := 0; i < len(m.Tables); i++ {
		if swag.IsZero(m.Tables[i]) { // not required
			continue
		}

		if m.Tables[i] != nil {
			if err := m.Tables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this openapi import item spec target based on the context it is used
func (m *OpenapiImportItemSpecTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecTarget) contextValidateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tables); i++ {

		if m.Tables[i] != nil {

			if swag.IsZero(m.Tables[i]) { // not required
				return nil
			}

			if err := m.Tables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpecTarget) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpecTarget) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpecTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemSpecTargetTablesItems0 ImportTargetTable
//
// ImportTargetTable represents the settings for importing source data into a single target table of an import task.
//
// swagger:model OpenapiImportItemSpecTargetTablesItems0
type OpenapiImportItemSpecTargetTablesItems0 struct {

	// The target database name.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
	// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
	// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
	//
	// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
	//
	// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
	//
	// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
	// Example: data/db01/table01.*.csv
	FileNamePattern string `json:"file_name_pattern,omitempty"`

	// The target table name.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this openapi import item spec target tables items0
func (m *OpenapiImportItemSpecTargetTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemSpecTargetTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", m.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiImportItemSpecTargetTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", m.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi import item spec target tables items0 based on context it is used
func (m *OpenapiImportItemSpecTargetTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemSpecTargetTablesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemSpecTargetTablesItems0) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemSpecTargetTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemStatus ImportStatus
//
// The status of the import task.
//
// swagger:model OpenapiImportItemStatus
type OpenapiImportItemStatus struct {

	// The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
	// Example: 1676450897
	EndTimestamp string `json:"end_timestamp,omitempty"`

	// The error message of the import task.
	// Example: some error occurs
	ErrorMessage string `json:"error_message,omitempty"`

	// The current phase that the import task is in.
	// Example: IMPORTING
	// Required: true
	// Enum: [PREPARING IMPORTING COMPLETED FAILED CANCELING CANCELED]
	Phase *string `json:"phase"`

	// progress
	Progress *OpenapiImportItemStatusProgress `json:"progress,omitempty"`

	// The total size of the import task's data source. The unit is bytes.
	// Example: 10737418240
	SourceTotalSizeBytes string `json:"source_total_size_bytes,omitempty"`

	// The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
	// Example: 1676450597
	StartTimestamp string `json:"start_timestamp,omitempty"`
}

// Validate validates this openapi import item status
func (m *OpenapiImportItemStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePhase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var openapiImportItemStatusTypePhasePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PREPARING","IMPORTING","COMPLETED","FAILED","CANCELING","CANCELED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		openapiImportItemStatusTypePhasePropEnum = append(openapiImportItemStatusTypePhasePropEnum, v)
	}
}

const (

	// OpenapiImportItemStatusPhasePREPARING captures enum value "PREPARING"
	OpenapiImportItemStatusPhasePREPARING string = "PREPARING"

	// OpenapiImportItemStatusPhaseIMPORTING captures enum value "IMPORTING"
	OpenapiImportItemStatusPhaseIMPORTING string = "IMPORTING"

	// OpenapiImportItemStatusPhaseCOMPLETED captures enum value "COMPLETED"
	OpenapiImportItemStatusPhaseCOMPLETED string = "COMPLETED"

	// OpenapiImportItemStatusPhaseFAILED captures enum value "FAILED"
	OpenapiImportItemStatusPhaseFAILED string = "FAILED"

	// OpenapiImportItemStatusPhaseCANCELING captures enum value "CANCELING"
	OpenapiImportItemStatusPhaseCANCELING string = "CANCELING"

	// OpenapiImportItemStatusPhaseCANCELED captures enum value "CANCELED"
	OpenapiImportItemStatusPhaseCANCELED string = "CANCELED"
)

// prop value enum
func (m *OpenapiImportItemStatus) validatePhaseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, openapiImportItemStatusTypePhasePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OpenapiImportItemStatus) validatePhase(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"phase", "body", m.Phase); err != nil {
		return err
	}

	// value enum
	if err := m.validatePhaseEnum("status"+"."+"phase", "body", *m.Phase); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiImportItemStatus) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this openapi import item status based on the context it is used
func (m *OpenapiImportItemStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemStatus) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {

		if swag.IsZero(m.Progress) { // not required
			return nil
		}

		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemStatus) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiImportItemStatusProgress ImportProgress
//
// The progress of the import task.
//
// swagger:model OpenapiImportItemStatusProgress
type OpenapiImportItemStatusProgress struct {

	// The overall importing progress of the import task.
	// Example: 59
	// Required: true
	// Maximum: 100
	ImportProgress *float64 `json:"import_progress"`

	// The overall validation progress of the import task after the data has been imported into the target cluster.
	// Example: 59
	// Required: true
	// Maximum: 100
	ValidationProgress *float64 `json:"validation_progress"`
}

// Validate validates this openapi import item status progress
func (m *OpenapiImportItemStatusProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateImportProgress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiImportItemStatusProgress) validateImportProgress(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"progress"+"."+"import_progress", "body", m.ImportProgress); err != nil {
		return err
	}

	if err := validate.Maximum("status"+"."+"progress"+"."+"import_progress", "body", *m.ImportProgress, 100, false); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiImportItemStatusProgress) validateValidationProgress(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"progress"+"."+"validation_progress", "body", m.ValidationProgress); err != nil {
		return err
	}

	if err := validate.Maximum("status"+"."+"progress"+"."+"validation_progress", "body", *m.ValidationProgress, 100, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi import item status progress based on context it is used
func (m *OpenapiImportItemStatusProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiImportItemStatusProgress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiImportItemStatusProgress) UnmarshalBinary(b []byte) error {
	var res OpenapiImportItemStatusProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
