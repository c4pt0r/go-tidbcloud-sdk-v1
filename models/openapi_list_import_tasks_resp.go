// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OpenapiListImportTasksResp ListImportTasksResp
//
// ListImportTasksResp is the response for listing the import tasks of a cluster.
//
// swagger:model openapiListImportTasksResp
type OpenapiListImportTasksResp struct {

	// The import tasks in the cluster in the request page area.
	// Required: true
	Items []*OpenapiListImportTasksRespItemsItems0 `json:"items"`

	// The total number of import tasks in the cluster.
	// Example: 20
	// Required: true
	Total *int64 `json:"total"`
}

// Validate validates this openapi list import tasks resp
func (m *OpenapiListImportTasksResp) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotal(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksResp) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OpenapiListImportTasksResp) validateTotal(formats strfmt.Registry) error {

	if err := validate.Required("total", "body", m.Total); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this openapi list import tasks resp based on the context it is used
func (m *OpenapiListImportTasksResp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksResp) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {

			if swag.IsZero(m.Items[i]) { // not required
				return nil
			}

			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksResp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksResp) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksResp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0 ImportItem
//
// ImportItem represents the information of a single import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0
type OpenapiListImportTasksRespItemsItems0 struct {

	// metadata
	Metadata *OpenapiListImportTasksRespItemsItems0Metadata `json:"metadata,omitempty"`

	// spec
	Spec *OpenapiListImportTasksRespItemsItems0Spec `json:"spec,omitempty"`

	// status
	Status *OpenapiListImportTasksRespItemsItems0Status `json:"status,omitempty"`
}

// Validate validates this openapi list import tasks resp items items0
func (m *OpenapiListImportTasksRespItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0) validateSpec(formats strfmt.Registry) error {
	if swag.IsZero(m.Spec) { // not required
		return nil
	}

	if m.Spec != nil {
		if err := m.Spec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this openapi list import tasks resp items items0 based on the context it is used
func (m *OpenapiListImportTasksRespItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {

		if swag.IsZero(m.Metadata) { // not required
			return nil
		}

		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0) contextValidateSpec(ctx context.Context, formats strfmt.Registry) error {

	if m.Spec != nil {

		if swag.IsZero(m.Spec) { // not required
			return nil
		}

		if err := m.Spec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {

		if swag.IsZero(m.Status) { // not required
			return nil
		}

		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0Metadata ImportMetadata
//
// The metadata of the import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0Metadata
type OpenapiListImportTasksRespItemsItems0Metadata struct {

	// The creation time of the import task in Unix timestamp seconds (epoch time).
	// Example: 1676450597
	// Required: true
	CreateTimestamp *string `json:"create_timestamp"`

	// The ID of the import task.
	// Example: 1
	// Required: true
	ID *string `json:"id"`

	// The name of the import task.
	// Example: my_import
	Name string `json:"name,omitempty"`
}

// Validate validates this openapi list import tasks resp items items0 metadata
func (m *OpenapiListImportTasksRespItemsItems0Metadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Metadata) validateCreateTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("metadata"+"."+"create_timestamp", "body", m.CreateTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Metadata) validateID(formats strfmt.Registry) error {

	if err := validate.Required("metadata"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi list import tasks resp items items0 metadata based on context it is used
func (m *OpenapiListImportTasksRespItemsItems0Metadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0Metadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0Metadata) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0Metadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0Spec ImportSpec
//
// The specification of the import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0Spec
type OpenapiListImportTasksRespItemsItems0Spec struct {

	// source
	// Required: true
	Source *OpenapiListImportTasksRespItemsItems0SpecSource `json:"source"`

	// target
	// Required: true
	Target *OpenapiListImportTasksRespItemsItems0SpecTarget `json:"target"`
}

// Validate validates this openapi list import tasks resp items items0 spec
func (m *OpenapiListImportTasksRespItemsItems0Spec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Spec) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source", "body", m.Source); err != nil {
		return err
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Spec) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"target", "body", m.Target); err != nil {
		return err
	}

	if m.Target != nil {
		if err := m.Target.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this openapi list import tasks resp items items0 spec based on the context it is used
func (m *OpenapiListImportTasksRespItemsItems0Spec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Spec) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {

		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Spec) contextValidateTarget(ctx context.Context, formats strfmt.Registry) error {

	if m.Target != nil {

		if err := m.Target.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "target")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "target")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0Spec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0Spec) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0Spec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0SpecSource ImportSource
//
// The data source settings of the import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0SpecSource
type OpenapiListImportTasksRespItemsItems0SpecSource struct {

	// aws assume role access
	AwsAssumeRoleAccess *OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess `json:"aws_assume_role_access,omitempty"`

	// aws key access
	AwsKeyAccess *OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess `json:"aws_key_access,omitempty"`

	// format
	// Required: true
	Format *OpenapiListImportTasksRespItemsItems0SpecSourceFormat `json:"format"`

	// The data source type of an import task.
	//
	// - `"S3"`: import data from Amazon S3
	// - `"GCS"`: import data from Google Cloud Storage
	// - `"LOCAL_FILE"`: import data from a local file (only available for [TiDB Serverless](https://docs.pingcap.com/tidbcloud/select-cluster-tier#tidb-serverless) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
	//
	// **Note:** Currently, if this import spec is used for a [preview](#tag/Import/operation/PreviewImportData) request, only the `LOCAL_FILE` source type is supported.
	// Example: S3
	// Required: true
	// Enum: [S3 GCS LOCAL_FILE]
	Type *string `json:"type"`

	// The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
	// * `S3`: `s3://`
	// * `GCS`: `gs://`
	// * `LOCAL_FILE`: `file://`.
	//
	// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
	//
	// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
	// Example: s3://example-bucket/example-source-data/
	// Required: true
	URI *string `json:"uri"`
}

// Validate validates this openapi list import tasks resp items items0 spec source
func (m *OpenapiListImportTasksRespItemsItems0SpecSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAwsAssumeRoleAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsKeyAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) validateAwsAssumeRoleAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsAssumeRoleAccess) { // not required
		return nil
	}

	if m.AwsAssumeRoleAccess != nil {
		if err := m.AwsAssumeRoleAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) validateAwsKeyAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsKeyAccess) { // not required
		return nil
	}

	if m.AwsKeyAccess != nil {
		if err := m.AwsKeyAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"format", "body", m.Format); err != nil {
		return err
	}

	if m.Format != nil {
		if err := m.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

var openapiListImportTasksRespItemsItems0SpecSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","GCS","LOCAL_FILE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		openapiListImportTasksRespItemsItems0SpecSourceTypeTypePropEnum = append(openapiListImportTasksRespItemsItems0SpecSourceTypeTypePropEnum, v)
	}
}

const (

	// OpenapiListImportTasksRespItemsItems0SpecSourceTypeS3 captures enum value "S3"
	OpenapiListImportTasksRespItemsItems0SpecSourceTypeS3 string = "S3"

	// OpenapiListImportTasksRespItemsItems0SpecSourceTypeGCS captures enum value "GCS"
	OpenapiListImportTasksRespItemsItems0SpecSourceTypeGCS string = "GCS"

	// OpenapiListImportTasksRespItemsItems0SpecSourceTypeLOCALFILE captures enum value "LOCAL_FILE"
	OpenapiListImportTasksRespItemsItems0SpecSourceTypeLOCALFILE string = "LOCAL_FILE"
)

// prop value enum
func (m *OpenapiListImportTasksRespItemsItems0SpecSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, openapiListImportTasksRespItemsItems0SpecSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) validateType(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("spec"+"."+"source"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) validateURI(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"uri", "body", m.URI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this openapi list import tasks resp items items0 spec source based on the context it is used
func (m *OpenapiListImportTasksRespItemsItems0SpecSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAwsAssumeRoleAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAwsKeyAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) contextValidateAwsAssumeRoleAccess(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsAssumeRoleAccess != nil {

		if swag.IsZero(m.AwsAssumeRoleAccess) { // not required
			return nil
		}

		if err := m.AwsAssumeRoleAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_assume_role_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) contextValidateAwsKeyAccess(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsKeyAccess != nil {

		if swag.IsZero(m.AwsKeyAccess) { // not required
			return nil
		}

		if err := m.AwsKeyAccess.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "aws_key_access")
			}
			return err
		}
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSource) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if m.Format != nil {

		if err := m.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSource) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0SpecSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess AwsAssumeRoleAccess
//
// The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
//
// swagger:model OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess
type OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess struct {

	// The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
	// Example: arn:aws:iam::999999999999:role/sample-role
	// Required: true
	AssumeRole *string `json:"assume_role"`
}

// Validate validates this openapi list import tasks resp items items0 spec source aws assume role access
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssumeRole(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess) validateAssumeRole(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_assume_role_access"+"."+"assume_role", "body", m.AssumeRole); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi list import tasks resp items items0 spec source aws assume role access based on context it is used
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0SpecSourceAwsAssumeRoleAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess AwsKeyAccess
//
// The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
//
// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
//
// swagger:model OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess
type OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess struct {

	// The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_ACCESS_KEY_ID
	// Required: true
	AccessKeyID *string `json:"access_key_id"`

	// The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
	// Example: YOUR_SECRET_ACCESS_KEY
	// Required: true
	SecretAccessKey *string `json:"secret_access_key"`
}

// Validate validates this openapi list import tasks resp items items0 spec source aws key access
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecretAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess) validateAccessKeyID(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_key_access"+"."+"access_key_id", "body", m.AccessKeyID); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess) validateSecretAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"aws_key_access"+"."+"secret_access_key", "body", m.SecretAccessKey); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi list import tasks resp items items0 spec source aws key access based on context it is used
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0SpecSourceAwsKeyAccess
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0SpecSourceFormat ImportSourceFormat
//
// The format settings of the import data source.
//
// swagger:model OpenapiListImportTasksRespItemsItems0SpecSourceFormat
type OpenapiListImportTasksRespItemsItems0SpecSourceFormat struct {

	// csv config
	CsvConfig *OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig `json:"csv_config,omitempty"`

	// The format type of an import source.
	// Example: CSV
	// Required: true
	// Enum: [CSV PARQUET SQL AURORA_SNAPSHOT]
	Type *string `json:"type"`
}

// Validate validates this openapi list import tasks resp items items0 spec source format
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCsvConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) validateCsvConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.CsvConfig) { // not required
		return nil
	}

	if m.CsvConfig != nil {
		if err := m.CsvConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

var openapiListImportTasksRespItemsItems0SpecSourceFormatTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV","PARQUET","SQL","AURORA_SNAPSHOT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		openapiListImportTasksRespItemsItems0SpecSourceFormatTypeTypePropEnum = append(openapiListImportTasksRespItemsItems0SpecSourceFormatTypeTypePropEnum, v)
	}
}

const (

	// OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypeCSV captures enum value "CSV"
	OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypeCSV string = "CSV"

	// OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypePARQUET captures enum value "PARQUET"
	OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypePARQUET string = "PARQUET"

	// OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypeSQL captures enum value "SQL"
	OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypeSQL string = "SQL"

	// OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypeAURORASNAPSHOT captures enum value "AURORA_SNAPSHOT"
	OpenapiListImportTasksRespItemsItems0SpecSourceFormatTypeAURORASNAPSHOT string = "AURORA_SNAPSHOT"
)

// prop value enum
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, openapiListImportTasksRespItemsItems0SpecSourceFormatTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) validateType(formats strfmt.Registry) error {

	if err := validate.Required("spec"+"."+"source"+"."+"format"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("spec"+"."+"source"+"."+"format"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this openapi list import tasks resp items items0 spec source format based on the context it is used
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCsvConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) contextValidateCsvConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.CsvConfig != nil {

		if swag.IsZero(m.CsvConfig) { // not required
			return nil
		}

		if err := m.CsvConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spec" + "." + "source" + "." + "format" + "." + "csv_config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormat) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0SpecSourceFormat
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig ImportSourceCSVConfig
//
// The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
//
// swagger:model OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig
type OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig struct {

	// Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
	//
	// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
	BackslashEscape *bool `json:"backslash_escape,omitempty"`

	// The delimiter character used to separate fields in the CSV data.
	Delimiter *string `json:"delimiter,omitempty"`

	// Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
	HasHeaderRow *bool `json:"has_header_row,omitempty"`

	// The character used to quote the fields in the CSV data.
	Quote *string `json:"quote,omitempty"`
}

// Validate validates this openapi list import tasks resp items items0 spec source format csv config
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this openapi list import tasks resp items items0 spec source format csv config based on context it is used
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0SpecSourceFormatCsvConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0SpecTarget ImportTarget
//
// The target settings of the import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0SpecTarget
type OpenapiListImportTasksRespItemsItems0SpecTarget struct {

	// The settings for each target table that is being imported for the import task. If you leave it empty, the system will scan all the files in the data source using the default file patterns and collect all the tables to import. The files include data files, table schema files, and DB schema files. If you provide a list of tables, only those tables will be imported. For more information about the default file pattern, see [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Limitations:**
	// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
	// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
	// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
	Tables []*OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0 `json:"tables"`
}

// Validate validates this openapi list import tasks resp items items0 spec target
func (m *OpenapiListImportTasksRespItemsItems0SpecTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecTarget) validateTables(formats strfmt.Registry) error {
	if swag.IsZero(m.Tables) { // not required
		return nil
	}

	for i := 0; i < len(m.Tables); i++ {
		if swag.IsZero(m.Tables[i]) { // not required
			continue
		}

		if m.Tables[i] != nil {
			if err := m.Tables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this openapi list import tasks resp items items0 spec target based on the context it is used
func (m *OpenapiListImportTasksRespItemsItems0SpecTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecTarget) contextValidateTables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tables); i++ {

		if m.Tables[i] != nil {

			if swag.IsZero(m.Tables[i]) { // not required
				return nil
			}

			if err := m.Tables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("spec" + "." + "target" + "." + "tables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecTarget) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecTarget) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0SpecTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0 ImportTargetTable
//
// ImportTargetTable represents the settings for importing source data into a single target table of an import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0
type OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0 struct {

	// The target database name.
	// Example: db01
	// Required: true
	DatabaseName *string `json:"database_name"`

	// The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
	// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
	// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
	//
	// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
	//
	// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
	//
	// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
	//
	// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
	// Example: data/db01/table01.*.csv
	FileNamePattern string `json:"file_name_pattern,omitempty"`

	// The target table name.
	// Example: table01
	// Required: true
	TableName *string `json:"table_name"`
}

// Validate validates this openapi list import tasks resp items items0 spec target tables items0
func (m *OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDatabaseName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0) validateDatabaseName(formats strfmt.Registry) error {

	if err := validate.Required("database_name", "body", m.DatabaseName); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("table_name", "body", m.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi list import tasks resp items items0 spec target tables items0 based on context it is used
func (m *OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0SpecTargetTablesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0Status ImportStatus
//
// The status of the import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0Status
type OpenapiListImportTasksRespItemsItems0Status struct {

	// The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
	// Example: 1676450897
	EndTimestamp string `json:"end_timestamp,omitempty"`

	// The error message of the import task.
	// Example: some error occurs
	ErrorMessage string `json:"error_message,omitempty"`

	// The current phase that the import task is in.
	// Example: IMPORTING
	// Required: true
	// Enum: [PREPARING IMPORTING COMPLETED FAILED CANCELING CANCELED]
	Phase *string `json:"phase"`

	// progress
	Progress *OpenapiListImportTasksRespItemsItems0StatusProgress `json:"progress,omitempty"`

	// The total size of the import task's data source. The unit is bytes.
	// Example: 10737418240
	SourceTotalSizeBytes string `json:"source_total_size_bytes,omitempty"`

	// The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
	// Example: 1676450597
	StartTimestamp string `json:"start_timestamp,omitempty"`
}

// Validate validates this openapi list import tasks resp items items0 status
func (m *OpenapiListImportTasksRespItemsItems0Status) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePhase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var openapiListImportTasksRespItemsItems0StatusTypePhasePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PREPARING","IMPORTING","COMPLETED","FAILED","CANCELING","CANCELED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		openapiListImportTasksRespItemsItems0StatusTypePhasePropEnum = append(openapiListImportTasksRespItemsItems0StatusTypePhasePropEnum, v)
	}
}

const (

	// OpenapiListImportTasksRespItemsItems0StatusPhasePREPARING captures enum value "PREPARING"
	OpenapiListImportTasksRespItemsItems0StatusPhasePREPARING string = "PREPARING"

	// OpenapiListImportTasksRespItemsItems0StatusPhaseIMPORTING captures enum value "IMPORTING"
	OpenapiListImportTasksRespItemsItems0StatusPhaseIMPORTING string = "IMPORTING"

	// OpenapiListImportTasksRespItemsItems0StatusPhaseCOMPLETED captures enum value "COMPLETED"
	OpenapiListImportTasksRespItemsItems0StatusPhaseCOMPLETED string = "COMPLETED"

	// OpenapiListImportTasksRespItemsItems0StatusPhaseFAILED captures enum value "FAILED"
	OpenapiListImportTasksRespItemsItems0StatusPhaseFAILED string = "FAILED"

	// OpenapiListImportTasksRespItemsItems0StatusPhaseCANCELING captures enum value "CANCELING"
	OpenapiListImportTasksRespItemsItems0StatusPhaseCANCELING string = "CANCELING"

	// OpenapiListImportTasksRespItemsItems0StatusPhaseCANCELED captures enum value "CANCELED"
	OpenapiListImportTasksRespItemsItems0StatusPhaseCANCELED string = "CANCELED"
)

// prop value enum
func (m *OpenapiListImportTasksRespItemsItems0Status) validatePhaseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, openapiListImportTasksRespItemsItems0StatusTypePhasePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Status) validatePhase(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"phase", "body", m.Phase); err != nil {
		return err
	}

	// value enum
	if err := m.validatePhaseEnum("status"+"."+"phase", "body", *m.Phase); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Status) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this openapi list import tasks resp items items0 status based on the context it is used
func (m *OpenapiListImportTasksRespItemsItems0Status) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0Status) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {

		if swag.IsZero(m.Progress) { // not required
			return nil
		}

		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status" + "." + "progress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0Status) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0Status) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0Status
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OpenapiListImportTasksRespItemsItems0StatusProgress ImportProgress
//
// The progress of the import task.
//
// swagger:model OpenapiListImportTasksRespItemsItems0StatusProgress
type OpenapiListImportTasksRespItemsItems0StatusProgress struct {

	// The overall importing progress of the import task.
	// Example: 59
	// Required: true
	// Maximum: 100
	ImportProgress *float64 `json:"import_progress"`

	// The overall validation progress of the import task after the data has been imported into the target cluster.
	// Example: 59
	// Required: true
	// Maximum: 100
	ValidationProgress *float64 `json:"validation_progress"`
}

// Validate validates this openapi list import tasks resp items items0 status progress
func (m *OpenapiListImportTasksRespItemsItems0StatusProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateImportProgress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0StatusProgress) validateImportProgress(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"progress"+"."+"import_progress", "body", m.ImportProgress); err != nil {
		return err
	}

	if err := validate.Maximum("status"+"."+"progress"+"."+"import_progress", "body", *m.ImportProgress, 100, false); err != nil {
		return err
	}

	return nil
}

func (m *OpenapiListImportTasksRespItemsItems0StatusProgress) validateValidationProgress(formats strfmt.Registry) error {

	if err := validate.Required("status"+"."+"progress"+"."+"validation_progress", "body", m.ValidationProgress); err != nil {
		return err
	}

	if err := validate.Maximum("status"+"."+"progress"+"."+"validation_progress", "body", *m.ValidationProgress, 100, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this openapi list import tasks resp items items0 status progress based on context it is used
func (m *OpenapiListImportTasksRespItemsItems0StatusProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0StatusProgress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OpenapiListImportTasksRespItemsItems0StatusProgress) UnmarshalBinary(b []byte) error {
	var res OpenapiListImportTasksRespItemsItems0StatusProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
